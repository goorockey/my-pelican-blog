<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Goorockey's Blog</title><link href="http://www.goorockey.com/" rel="alternate"></link><link href="http://www.goorockey.com/feeds/network.atom.xml" rel="self"></link><id>http://www.goorockey.com/</id><updated>2012-03-15T00:00:00+08:00</updated><entry><title>用VMWare组网，实验DNS隧道</title><link href="http://www.goorockey.com/blog/2012/03/15/yong-vmwarezu-wang-shi-yan-dnssui-dao/" rel="alternate"></link><updated>2012-03-15T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2012-03-15:blog/2012/03/15/yong-vmwarezu-wang-shi-yan-dnssui-dao/</id><summary type="html">
&lt;p&gt;继续用VMWare来组网，这次要测试我想试很久的DNS隧道，之前碍于没有找到有独立ip的方法（当然是要免费的~~），现在用VMWare就可以了。&lt;/p&gt;
&lt;p&gt;DNS隧道是什么就不解释了。google一下DNS隧道能搜到风河、云风两个大牛相关的blog。这次我用iodine来实现DNS隧道。&lt;/p&gt;
&lt;h2 id="_1"&gt;场景&lt;/h2&gt;
&lt;p&gt;现在情况是，用户只能跟外界有DNS通路，想借此进行平常的http、ftp等通信。&lt;/p&gt;
&lt;p&gt;据说平常的CMCC等开放热点，虽然http等要账号和密码，但DNS是通的，然后你懂的了。&lt;/p&gt;
&lt;p&gt;简单的拓扑图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/image_thumb2.png"/&gt;&lt;/p&gt;
&lt;p&gt;整个回路就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用户把要想跟外网进行通信的数据包用DNS协议封装&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到的DNS包发送给DNS服务器，要求做DNS解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS服务器根据域名，解析出DNS代理的ip，并把数据包发给它&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS代理把数据包解封，并转发给外网的目标地址&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外网回复的数据包原路返回，这样就完成通讯了。
 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="vmware"&gt;VMWare环境模拟&lt;/h2&gt;
&lt;p&gt;这次我用了三台机子，系统还是CentOS 6.0：&lt;/p&gt;
&lt;p&gt;主机名 角色 网卡ip&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="err"&gt;用户&lt;/span&gt; &lt;span class="mf"&gt;192.168.149.128&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;代理&lt;/span&gt; &lt;span class="mf"&gt;192.168.126.130&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;服务器&lt;/span&gt; &lt;span class="mf"&gt;192.168.149.130&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="mf"&gt;192.168.126.233&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要模拟的初始状态就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;（用户）可以跟&lt;/span&gt;&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt;做&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;解析，但不能访问外网&lt;/span&gt; &lt;span class="err"&gt;。    &lt;/span&gt; &lt;span class="err"&gt;（所以虚拟网卡用&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="err"&gt;模式）&lt;/span&gt;
&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;代理）可以跟外网通信。           &lt;/span&gt; &lt;span class="err"&gt;（用&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="err"&gt;和&lt;/span&gt;&lt;span class="n"&gt;Bridged&lt;/span&gt;&lt;span class="err"&gt;都可以，这次我选用&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;
&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;服务器）可以跟&lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;进行&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt;解析，且能跟&lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;通信。  &lt;/span&gt; &lt;span class="err"&gt;（所以用两张网卡，为了分别跟&lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;和&lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;通信）&lt;/span&gt;
&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="n"&gt;iptables&lt;/span&gt;&lt;span class="err"&gt;不允许&lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;和&lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;之间互访&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="dns"&gt;DNS服务器配置&lt;/h2&gt;
&lt;p&gt;刚开始看教程好像很繁琐，感觉conf文件好多啊，而且配置项也多~~&lt;/p&gt;
&lt;p&gt;静下心来看，其实要实现最基本的的DNS解析很简单，主要就是修改两个文件。&lt;/p&gt;
&lt;p&gt;1.安装&lt;/p&gt;
&lt;p&gt;需要在HostC执行以下命令，安装DNS服务器所需的bind和caching-nameserver：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;chroot&lt;/span&gt; &lt;span class="n"&gt;caching&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;nameserver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.修改named的conf文件（/etc/named.conf）&lt;/p&gt;
&lt;p&gt;添加域名goorockey.go域名的配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;zone&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="err"&gt;     &lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zone&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;allow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;zone “ goorockey.go”： 指示要添加goorockey.go这个域名的正向解析。正向解析就是指域名到ip的解析，反向解析是指ip到域名的解析。例如想通过查询DNS服务器，知道192.168.0.1判定了多少域名，则在DNS服务器上配置zone “1.0.168.192.in-addr-arpa”的项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type master：对于goorockey.go这个域名，当前DNS服务器是它的主DNS服务器。type可以还可以使hint和slave。只有zone “.”可以配置type hint。type slave是指对于这个域名，当前DNS服务器是辅助DNS服务器，即它的DNS记录是从主服务器拷贝过来的，目的是为了达到DNS解析的分布式、负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;file “goorockey.go.zone”：这个域名的DNS记录文件在goorockey.go.zone，文件所在目录在/etc/named.conf的options项中的directory来定义。默认是/var/named&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allow-update：定义时候允许更新&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意的是，/etc/named.conf中的options项是所有域名的全局配置。默认时，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allow-query   {   localhost;   };&lt;/code&gt; 意思是只允许本机做DNS查询，当然要把它注释掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;listen-port    53    {  127.0.0.1;   };&lt;/code&gt; 意思是服务端口为53，但监听的ip是127.0.0.1，这样就不能让别的机子访问DNS解析服务了。所以可以把这句话注释掉，或者把ip改为0.0.0.0或指定ip。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.编辑goorockey.go的DNS记录文件&lt;/p&gt;
&lt;p&gt;根据我们在/etc/named.conf的配置，文件是/var/named/goorockey.go.zone。&lt;/p&gt;
&lt;p&gt;创建此文件，并编辑内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;@ &lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;SOA&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20120315&lt;/span&gt; &lt;span class="mi"&gt;3600&lt;/span&gt; &lt;span class="mi"&gt;1800&lt;/span&gt; &lt;span class="mi"&gt;36000&lt;/span&gt; &lt;span class="mi"&gt;3600&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.126.130&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;大概解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一行是一条SOA记录。@指代当前域名，就是/etc/named中的goorockey.go。SOA记录是域名有效性的相关属性。localhost.是主服务器的地址。root.localhost.是邮箱。主要DNS记录文件的地址都用FQDN，每个地址最后的句号“.”表示结束。如果没有句号“.”，会自动追加域名，例如没有句号的localhost会解释成”localhost.goorockey.go“。后面就是具体属性项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二行开始是两个空格，第一个空格表示继续上一条的内容，这里指”@“，第二个空格就是分割@和IN的。这一行表示域名goorockey.go的域名服务器是本机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三行是一条A记录，A for address。意思就是域名goorockey.go会解析成ip 192.168.126.130。可以看出，搞这么久，就是为了找到这句话。所以说A记录是DNS服务器的核心，就是它标明DNS解析的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS记录类型还会有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PTR用在反向解析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MX用在邮件服务器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TXT就是纯文本，对DNS服务器做标注&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.运行DNS服务&lt;/p&gt;
&lt;p&gt;在HostC执行： &lt;code&gt;$ service  named   start&lt;/code&gt; 或者 &lt;code&gt;$ /etc/init.d/named start&lt;/code&gt;,这就可以运行DNS服务了。&lt;/p&gt;
&lt;p&gt;对HostC的/etc/resolv.conf添加 &lt;code&gt;nameserver 127.0.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;则在HostC用nslookup能成功返回DNS信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/20594453_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt;但还要配置iptables，使其他机子可以访问DNS服务的端口。&lt;/p&gt;
&lt;p&gt;对于默认的53端口，在HostC运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;udp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要解释一下的是，DNS包有可能以tcp或者udp方式传输。一般首选是udp方式。但因为udp包长度只能是512字节，也不能分包，所以如果当DNS包长度大于512时，就会选择tcp方式。所以这里要对tcp和udp都设置ACCEPT。&lt;/p&gt;
&lt;p&gt;在HostA和HostB的/etc/resolv.conf添加HostA的ip后，就能正确解析goorockey.go了。&lt;/p&gt;
&lt;h2 id="iodine"&gt;iodine&lt;/h2&gt;
&lt;p&gt;iodine是外国人写的开源DNS隧道工具，有linux版、windows版和Mac版的。教程看它的ReadMe或者HowToSetup都比较清楚。&lt;/p&gt;
&lt;p&gt;下载并安装对应自己版本的iodine后就能使用了。&lt;/p&gt;
&lt;p&gt;在DNS隧道的服务器端(HostB)，先执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iodined&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="mf"&gt;10.0.0.1&lt;/span&gt; &lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输入密码后，服务端就运行了。注意服务端运行的是iodined，有”d“。&lt;/p&gt;
&lt;p&gt;在客户端（HostA)，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iodine&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.126.130&lt;/span&gt; &lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中192.168.126.130是服务端（HostB）的ip。&lt;/p&gt;
&lt;p&gt;然后还要配置一下，HostA，HostB，HostC的iptables，使它们的DNS包可以通过就可以了。&lt;/p&gt;
&lt;p&gt;这时候，HostA的虚拟网卡ip是10.0.0.2，HostB的虚拟网卡ip是10.0.0.1。两台机子已经建立了VPN。&lt;/p&gt;
&lt;p&gt;本来两台不能互访的机子就可以访问了。&lt;/p&gt;
&lt;p&gt;例如在HostA就可以ssh HostB了 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="mf"&gt;10.0.0.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后就可以用ssh隧道过去来做代理了~~&lt;/p&gt;
&lt;h2 id="_2"&gt;小结&lt;/h2&gt;
&lt;p&gt;那时候看到DNS隧道，真是非常的兴奋，感觉太爽、太妙了。其实协议都可以这样做隧道，只是那时候没有意识到而已。&lt;/p&gt;
&lt;p&gt;之后还继续想实验一下ICMP隧道，看一下iodine的代码。O(∩_∩)O哈哈~&lt;/p&gt;
&lt;h2 id="_3"&gt;参考资料：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;【风河的博文】&lt;a href="http://www.nsbeta.info/archives/96"&gt;http://www.nsbeta.info/archives/96&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【云风的博文】&lt;a href="http://blog.codingnow.com/2011/06/dns_tunnel.html"&gt;http://blog.codingnow.com/2011/06/dns_tunnel.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【iodine】&lt;a href="http://code.kryo.se/iodine/"&gt;http://code.kryo.se/iodine/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="network"></category><category term="vmware"></category><category term="隧道"></category></entry><entry><title>VMWare组网实验(NAT)</title><link href="http://www.goorockey.com/blog/2012/03/13/vmwarezu-wang-shi-yan-nat/" rel="alternate"></link><updated>2012-03-13T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2012-03-13:blog/2012/03/13/vmwarezu-wang-shi-yan-nat/</id><summary type="html">
&lt;p&gt;本着“干中学”的精神，看完资料，还是用VMWare来练习一下使用NAT，好加深认识。&lt;/p&gt;
&lt;p&gt;实验涉及：NAT，iptables，&lt;/p&gt;
&lt;h2 id="_1"&gt;实验目标&lt;/h2&gt;
&lt;p&gt;这次我要用iptables实现NAT功能（SNAT和DNAT）。&lt;/p&gt;
&lt;p&gt;先上拓扑图（可能有点不规范）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/image_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt;如图分别有4台机子：A、B在内网，但在不同的网段中，C做网关，控制网段间的访问。D在外网。&lt;/p&gt;
&lt;p&gt;要达到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A、B能通信（内网不同网段的互访）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A、B能通过C与外网通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D能通过C访问到A、B的服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;环境&lt;/h2&gt;
&lt;p&gt;用VMWare虚拟出这4台机子，VMWare的版本为8.0&lt;/p&gt;
&lt;p&gt;每台机子都跑CentOS 6.0&lt;/p&gt;
&lt;h2 id="vmware"&gt;VMWare环境配置&lt;/h2&gt;
&lt;p&gt;安装4个虚拟机，都装上CentOS，主机名分别定为hostA、hostB、hostC、hostD，对应A、B、C、D。&lt;/p&gt;
&lt;p&gt;VMWare新建几张网卡（菜单栏【edit】-【Virtual Network Editor】），要求一张为Bridged（NAT应该也行），两张为Host-only。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/151306312_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt;设置A、B网卡分别为VMnet1和VMnet2，这是为了使它们原始都不能互访。&lt;/p&gt;
&lt;p&gt;外网的D网卡设为VMnet0&lt;/p&gt;
&lt;p&gt;C则有三张网卡VMnet0、VMnet1、VMnet2，这样C原始都能访问到A、B、D。&lt;/p&gt;
&lt;p&gt;然后进入每个虚拟机，为了方便，我都设置为静态ip（网段跟上图对应）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.149.128&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.214.128&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.4.233&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth0&lt;/span&gt;&lt;span class="err"&gt;），&lt;/span&gt;&lt;span class="mf"&gt;192.168.149.130&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth1&lt;/span&gt;&lt;span class="err"&gt;），&lt;/span&gt;&lt;span class="mf"&gt;192.168.214.130&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth2&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.4.234&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CentOS里面配置网卡方法就是修改/etc/sysconfig/network-scripts/ifcfg-eth*，没有则自己创建一个。&lt;/p&gt;
&lt;p&gt;关键项就是ONBOOT，IPADDR，NETMASK，GATEWAY，DNS1，DNS2，PEERDNS&lt;/p&gt;
&lt;p&gt;要注意的是，有PEERDNS项，当它值为yes，则会把DNS1和DNS2覆盖地写入/etc/resolv.conf。&lt;/p&gt;
&lt;p&gt;这对于多网卡的C，如果ifcfg-eth0、ifcfg-eth1、ifcfg-eth2都设了PEERDNS，由于开机是按名字的顺序执行，则会把ifcfg-eth2的DNS写入/etc/resolv.conf，前两个文件的DNS会无效了的。所以我只在ifcfg-eth0配置PEERDNS=“yes“。&lt;/p&gt;
&lt;p&gt;好，初步网络环境配置完成。&lt;/p&gt;
&lt;p&gt;现在情况是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ABD&lt;/span&gt;&lt;span class="err"&gt;都不能互访，因为在不同的网段&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt;则都能跟它们三个互访&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="ciptablesnat"&gt;配置网关C的iptables，实现NAT&lt;/h2&gt;
&lt;p&gt;到关键也是好玩的地方了。&lt;/p&gt;
&lt;p&gt;接下来配置网关C的iptables，实现不同网络间地址的转换（NAT）。&lt;/p&gt;
&lt;p&gt;iptables内容比较多，详细可以参考：&lt;a href="http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html"&gt;http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.A、B通过C实现通信&lt;/p&gt;
&lt;p&gt;这个比较简单，没用到iptables，把A的网关设为C的对应网卡的ip（192.168.149.130），B的网关设为C对应网卡的ip（192.168.214.130）。&lt;/p&gt;
&lt;p&gt;然后打开C的ip转发，在C中执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;net&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ipv4&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ip_forward&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这就把C作为了A、B的网关。A、B间通信的数据包会发到C，靠C的网卡间转发来完成通信。AB就可以相互ping通了。&lt;/p&gt;
&lt;p&gt;2.A、B通过C与外网通信（SNAT）&lt;/p&gt;
&lt;p&gt;现在A、B都不能跟D通信，因为现在A、B发到D的数据包源地址（192.168.149.128,192.168.214.128），D是无法知道的（D在C的同一个网络，网关设为相同的ip）。则包可以发到D，但D回复不了，因为它的网关不知道A、B。&lt;/p&gt;
&lt;p&gt;现在就通过SNAT把A、B发送的包在经过C时，把源地址改为C的外网ip（192.168.4.233），这个D是知道的，也就可以顺利回复了。&lt;/p&gt;
&lt;p&gt;具体在C中执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt;&lt;span class="err"&gt; –&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;POSTROUTING&lt;/span&gt;&lt;span class="err"&gt; –&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;SNAT&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="mf"&gt;192.168.4.233&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样A、B就能ping通了。&lt;/p&gt;
&lt;p&gt;SNAT可以看看我的博文。 嘻嘻……&lt;/p&gt;
&lt;p&gt;3.D通过C访问A、B的服务（DNAT）&lt;/p&gt;
&lt;p&gt;现在A、B可以跟D通信，但D不能主动访问A、B。还是因为D只知道C，不知道A、B。&lt;/p&gt;
&lt;p&gt;假如现在A开了19991口的sshd：&lt;/p&gt;
&lt;p&gt;在A的/etc/ssh/sshd_config中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ListenAddress&lt;/span&gt; &lt;span class="mf"&gt;0.0.0.0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;19991&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重启sshd&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;sshd&lt;/span&gt; &lt;span class="n"&gt;restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在A中让iptables允许对19991口的访问&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;19991&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在D想ssh到A的19991，则可以在C中执行以下命令，实现DNAT：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;PREROUTING&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mi"&gt;19991&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;DNAT&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.149.128&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在D可以通过ssh到C的19991口来ssh到A了。&lt;/p&gt;
&lt;h2 id="_3"&gt;小结&lt;/h2&gt;
&lt;p&gt;整个实验搞完，对iptables，NAT的原理还是深刻了不少。&lt;/p&gt;
&lt;p&gt;然后，就是VMWare是个好东西。&lt;/p&gt;</summary><category term="network"></category><category term="vmware"></category><category term="nat"></category></entry><entry><title>NAT学习总结</title><link href="http://www.goorockey.com/blog/2012/03/11/natxue-xi-zong-jie/" rel="alternate"></link><updated>2012-03-11T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2012-03-11:blog/2012/03/11/natxue-xi-zong-jie/</id><summary type="html">
&lt;p&gt;最近要恶补一下计算机网络的基础知识，今天先总结一下NAT。&lt;/p&gt;
&lt;h2 id="nat"&gt;NAT的背景&lt;/h2&gt;
&lt;p&gt;随着Internet的普及，网络中的ip资源是越来越紧张。而NAT就是为了解决这个问题的方案。&lt;/p&gt;
&lt;p&gt;NAT是Network Address Translation,网络地址转换，会在网关中实现局域网内部ip和外网ip之间转换。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/nat.png"/&gt;&lt;/p&gt;
&lt;p&gt;如上图，局域网内部网段是192.168.1.X，这些ip只在这个局域网内有意义，外网无法根据这些ip定位计算机。&lt;/p&gt;
&lt;p&gt;而NAT就是做内网和外网这样两个网络间的ip转换。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="nat_1"&gt;NAT的类型&lt;/h2&gt;
&lt;p&gt;按照通信发起方的不同，NAT可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SNAT，即Source NAT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNAT，即Destination NAT&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.SNAT&lt;/p&gt;
&lt;p&gt;SNAT是对数据包源ip的转换，主要用于内网机子发起连接到外网的情况。&lt;/p&gt;
&lt;p&gt;【考虑以下场景】：&lt;/p&gt;
&lt;p&gt;内网ip为192.168.1.2的机子向外网的8.8.8.8发包。如果数据包的源ip直接就是192.168.1.2，数据包虽然可以成功到达8.8.8.8，但是它无法根据192.168.1.2的源ip回复数据包，因为在外网中没有192.168.1.2，则造成通信失败。&lt;/p&gt;
&lt;p&gt;而SNAT就是当内网发起连接到外网时，具有NAT功能的机子，例如网关，在数据包要出外网之前，把包的源ip改为这个局域网的外网ip，如1.1.1.1，同时会有映射表记录转换。&lt;/p&gt;
&lt;p&gt;由于1.1.1.1是外网中有意义的ip，1.1.1.1和8.8.8.8可以成功的完成数据包的发送和接受。这时8.8.8.8是把1.1.1.1作为目标ip回复数据包，网关收到数据包后，会查表把包的目标ip映射回内网机子ip 192.168.1.2。&lt;/p&gt;
&lt;p&gt;可以看出来，整个过程对内网机子是透明的，即发送和接受数据包的ip都对应，仿佛没有做过转换。&lt;/p&gt;
&lt;p&gt;2.DNAT&lt;/p&gt;
&lt;p&gt;DNAT是对数据包目标ip的转换，主要用于外网向内网发起连接的情况。&lt;/p&gt;
&lt;p&gt;【考虑一下场景】：&lt;/p&gt;
&lt;p&gt;在内网中有很多机子，其中有一台ip为192.168.1.2的机子是对外网提供服务的web服务器，现在外网的8.8.8.8要访问它。但对于8.8.8.8来说，web服务器所在ip会是192.168.1.2所在内网的外网ip，如1.1.1.1。&lt;/p&gt;
&lt;p&gt;可想而知，当8.8.8.8向1.1.1.1发送数据包，网关会做DNAT，把包的目标ip从1.1.1.1改为192.168.1.2，同时会把转换记录到一个表中。然后192.168.1.2回复数据包，包的源ip是192.168.1.2，目标ip会是8.8.8.8。网关接受到包后，则查表，把源ip修改回1.1.1.1。&lt;/p&gt;
&lt;h2 id="nat_2"&gt;NAT的转换方式&lt;/h2&gt;
&lt;p&gt;NAT有四种转换方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态NAT  (Static NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态NAT  (Dynamic NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过载     (Overload NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重叠     (Overlap NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.Static NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/nat-static.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;局域网有多个外网ip，数量等于或多于内网ip数。&lt;/p&gt;
&lt;p&gt;则做NAT转换时，每个内网ip对应一个外网ip。&lt;/p&gt;
&lt;p&gt;网关的表中记录着这样一对一的关系。&lt;/p&gt;
&lt;p&gt;2.Dynamic NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/nat-dynamic.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;局域网有多个外网ip，但数量少于内网ip数。&lt;/p&gt;
&lt;p&gt;则做转换时，每个内网ip从当前未被映射的外网ip选取一个来做转换。&lt;/p&gt;
&lt;p&gt;网关的表也会记录这种转换，且会根据情况不断更新。&lt;/p&gt;
&lt;p&gt;3.Overload NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/nat-overload.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;如果局域网只有一个外网ip，每个内网ip都映射到这个外网ip，但端口口会不同。&lt;/p&gt;
&lt;p&gt;网关的表中会记录这种端口的映射。&lt;/p&gt;
&lt;p&gt;4.Overlap NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/03/nat-overlap.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;当内网的ip在外网中已经注册且已被其他机子使用时，网关要在选择一个外网中已注册但未被使用的ip做转换。&lt;/p&gt;
&lt;p&gt;网关的表中记录这种转化。&lt;/p&gt;
&lt;h2 id="_1"&gt;小结&lt;/h2&gt;
&lt;p&gt;其实所谓的内网和外网都是相对而言，只要是两个网络间的通信，都可以或需要用网关或路由做NAT。&lt;/p&gt;
&lt;p&gt;【参考资料】：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://article.yeeyan.org/view/185403/150856"&gt;http://article.yeeyan.org/view/185403/150856&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/网络地址转换"&gt;http://zh.wikipedia.org/wiki/网络地址转换&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="network"></category><category term="nat"></category></entry><entry><title>SSH端口转发</title><link href="http://www.goorockey.com/blog/2012/02/22/sshduan-kou-zhuan-fa/" rel="alternate"></link><updated>2012-02-22T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2012-02-22:blog/2012/02/22/sshduan-kou-zhuan-fa/</id><summary type="html">
&lt;h2 id="ssh"&gt;ssh端口转发是什么&lt;/h2&gt;
&lt;p&gt;ssh端口转发也被叫ssh隧道，ssh代理。&lt;/p&gt;
&lt;p&gt;所谓隧道，就是用X协议封装Y协议的数据包，靠X协议来进行Y协议通信。&lt;/p&gt;
&lt;p&gt;总的来说ssh隧道提供了两个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;突破防火墙等，进行受限协议的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使如telnet等不安全的协议传输经过ssh的加密通道，提高安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id="ssh_1"&gt;三种ssh端口转发&lt;/h2&gt;
&lt;p&gt;ssh端口转发有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地转发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;远程转发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态转发&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt;本地转发&lt;/h2&gt;
&lt;p&gt;命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/02/image002_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;一个运行在服务器116.1.1.1的程序提供端口389的数据通信，但防火墙只允许其他计算机对服务器做ssh的通信。&lt;/p&gt;
&lt;p&gt;而客户端116.4.0.1为了完成通信，可以借助ssh的本地端口转发。&lt;/p&gt;
&lt;p&gt;在客户端执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="mi"&gt;7001&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;389&lt;/span&gt;&lt;span class="err"&gt;    &lt;/span&gt; &lt;span class="mf"&gt;116.1.1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同时把客户端程序输出到本机的7001端口。注意命令中的localhost是相对于116.1.1.1来说的。&lt;/p&gt;
&lt;p&gt;那么整个数据流会是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端程序到数据输出到客户端的7001口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端的ssh一直检测7001口，但发现本机有数据包到达，则把数据包加密，并通过跟服务端116.1.1.1的ssh通路传输&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端的sshd收到数据包后包解密，并转发到服务端的389口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端返回数据，并原路返回&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，在ssh本地转发命令中的remote host可以使任意的机子，包括本机或其他计算机。&lt;/p&gt;
&lt;p&gt;例如，考虑这样的场景，用本地转发来进行远程桌面：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/02/image_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt;现在要在机子A对机子C做远程桌面。但机子A和机子C都在不同的子网，不能直接通信，也都只能跟机子B用ssh通信。&lt;/p&gt;
&lt;p&gt;然后已知windows远程桌面的服务端端口是3389，这我们可以在机子A执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="mi"&gt;13389&lt;/span&gt;&lt;span class="o"&gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;3389&lt;/span&gt;&lt;span class="err"&gt;    &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;命令中的13389是任意的，但要注意只有管理员才能用1~1024的端口。&lt;/p&gt;
&lt;p&gt;然后在A机子执行yuan远程桌面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mstsc&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13389&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就能在A机子远程桌面控制C机子了。&lt;/p&gt;
&lt;h2 id="_2"&gt;远程转发&lt;/h2&gt;
&lt;p&gt;其实远程转发跟本地转发是基本相同的。&lt;/p&gt;
&lt;p&gt;命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;   &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/02/image003_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;客户端A和服务端B的端口都还是7001和389。&lt;/p&gt;
&lt;p&gt;跟本地转发时候不同的是，ssh连接的sshd在客户端A，ssh在服务端B。&lt;/p&gt;
&lt;p&gt;所以，远程转发可以应用在客户端A只允许对其做ssh连接的时候。&lt;/p&gt;
&lt;p&gt;如果客户端和服务端都允许ssh连接，那选择本地转发还是远程转发都可以。&lt;/p&gt;
&lt;h2 id="_3"&gt;动态转发&lt;/h2&gt;
&lt;p&gt;命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2012/02/image005_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;跟其他两种端口转发不同的是，动态转发在数据包经过ssh通过到达服务端后，sshd会根据把封装数据包的协议，转发到对应的主机和端口。&lt;/p&gt;
&lt;p&gt;这时候ssh隧道是充当了SOCKS代理的作用。这就可以用来翻X之类了。&lt;/p&gt;
&lt;h2 id="ending"&gt;Ending&lt;/h2&gt;
&lt;p&gt;总的来说，ssh是个好东西~~~&lt;/p&gt;
&lt;h2 id="_4"&gt;相关资料：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/"&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/"&gt;http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="network"></category><category term="ssh"></category></entry></feed>