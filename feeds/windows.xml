<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Goorockey's Blog</title><link href="http://www.goorockey.com/" rel="alternate"></link><link href="http://www.goorockey.com/feeds/windows.xml" rel="self"></link><id>http://www.goorockey.com/</id><updated>2011-09-05T00:00:00+08:00</updated><entry><title>《Windows核心编程》读书笔记3--线程同步</title><link href="http://www.goorockey.com/blog/2011/09/05/windowshe-xin-bian-cheng-du-shu-bi-ji-3-xian-cheng-tong-bu/" rel="alternate"></link><updated>2011-09-05T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2011-09-05:blog/2011/09/05/windowshe-xin-bian-cheng-du-shu-bi-ji-3-xian-cheng-tong-bu/</id><summary type="html">
&lt;h2 id="_1"&gt;原子操作&lt;/h2&gt;
&lt;p&gt;能调用的原子操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchangeAdd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plAddend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;Increment&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plTarget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lValue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchangePointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ppvTarget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvValue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedCompareExchange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plDestination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lExchange&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lComparand&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedCompareExchangePointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ppvDestination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvExchange&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvComparand&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;h2 id="_2"&gt;以查询方式同步&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="nf"&gt;WinMain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RecalcFunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;

    &lt;span class="c1"&gt;//Wait for the recalculation to complete. &lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="nf"&gt;RecalcFunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//Perform the recalculation. &lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;

    &lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;查询的线程一直处于可调度状态，浪费CPU时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果WinMain的线程优先级比ReclcFunc的线程要高，则g_fFinishedCalculation永远不会被置为TRUE。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="critical95section"&gt;关键代码段Critical_Section&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用前调用InitializeCriticalSection进行初始化，使用后用DeleteCriticalSection释放资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在指向同一个Critical_Section的EnterCriticalSection和LeaveCriticalSection之间的代码，不会被多个线程同时调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一个线程多次重入EnterCriticalSection和LeaveCriticalSection之间的代码不会发生死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如下面代码不会有死锁：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CRITICAL_SECTION&lt;/span&gt; &lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;InitializeCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;EnterCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;EnterCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;testing&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;LeaveCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;LeaveCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;考虑到线程进入等待状态时，要保护现场，这是非常耗时的。这可以用InitializeCriticalSectionAndSpinCount，它让想进入已被占用的关键代码段的线程先循环判断多次，才进入等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InitializeCriticalSectionAndSpinCount只对多个CPU起作用，单个CPU不起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SetCriticalSectionSpinCount可以改变循环判断的次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键代码段是在用户态实现同步的方法，这样比内核态同步要快，因为不用做用户态和内核态之间的往返（往返一次需要占用x 8 6平台上的大约1 0 0 0个C P U周期）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;内核对象同步&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当内核对象是自动设置为有信号时，在所有等待该内核对象的线程中，只会有一个变为可调度，然后该内核对象又自动设为无信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当内核对象是手动设置为有信号时，除非手动设置该内核对象的状态，否则一直是有信号，这样所有等待该内核对象的线程都能变为可调度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="waitabletimer"&gt;WaitableTimer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WaitableTimer能在规定时候或按规定的时间间隔变为有信号状态，就类似闹钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SetWaitableTimer设置开始定时的时间（如果传参是负数，则是相对于这个函数被调用的时间）、定时的间隔、定时间隔到时调用的函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CancelWaitableTimer取消WaitableTimer的定时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt;其他等待函数&lt;/h2&gt;
&lt;p&gt;--- | ---
MsgWaitForMultipleObjects和MsgWaitForMultipleObjectsEx | 等待多个内核对象有信号、或指定类型消息到达线程的输入队列
SingleObjectAndWait | 在一个原子操作完成设置一个内核对象为有信号，并进入等待另一个内核对象&lt;/p&gt;
&lt;h2 id="_5"&gt;各同步的内核对象的理解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关键代码段:&lt;/p&gt;
&lt;p&gt;critical section ,关键代码段之间的代码是原子操作，同一时间只能有一个线程执行该段代码，与别的同步object都是内核态的同步相比，它争取用用户态的方式进行同步，如果用户态的用户不行，才用内核态的同步，这样效率更高,花费较少&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁:&lt;/p&gt;
&lt;p&gt;mutex，只允许一个线程拥有
semaphore，允许指定数量的线程拥有，创建此object时可以指定能拥有的最多的线程数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号：&lt;/p&gt;
&lt;p&gt;event，不同于锁，就如它的名字是“信号”，当一个线程拥有锁的时候就会改变锁的状态以达到同步（`成功拥有mutex则使它无信号；成功拥有semaphore则使它计数减一，当计数为零，则semaphore变成无信号状态），手动设置的event的状态只有线程调用SetEvent或ResetEvent才会改变，线程则通过WaitForSingleObject等检测信号状态的函数来达到同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="windows"></category><category term="programming"></category></entry><entry><title>《Windows核心编程》读书笔记2--进程、作业、线程</title><link href="http://www.goorockey.com/blog/2011/09/03/windowshe-xin-bian-cheng-du-shu-bi-ji-2-jin-cheng-zuo-ye-xian-cheng/" rel="alternate"></link><updated>2011-09-03T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2011-09-03:blog/2011/09/03/windowshe-xin-bian-cheng-du-shu-bi-ji-2-jin-cheng-zuo-ye-xian-cheng/</id><summary type="html">
&lt;h2 id="_1"&gt;一、摘要：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程只是线程的容器，存放数据和代码，但不执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程才是执行代码的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作业是对一个或多个进程的统一管理，能添加一般无法添加的限制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt;二、进程&lt;/h2&gt;
&lt;p&gt;1.概念&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程只是线程的容器&lt;/strong&gt;，为线程执行代码提供资源、营造运行环境。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;2.进程的构成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;一块内存地址空间，用以存放代码和数据；
一个内核对象句柄表，记录使用中的内核对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;更详尽的构成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(来自MSDN &lt;a href="http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;executable&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;open&lt;/span&gt; &lt;span class="n"&gt;handles&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;environment&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;priority&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;minimum&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt; &lt;span class="n"&gt;working&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sizes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;least&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.进程的终止&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全部线程都结束。即使主线程退出了，如果还有线程存在，该进程仍然不会销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ExitProcess，有可能造成内存泄露，因为C/C++ Runtime Library没有被清空，则全局变量等资源就不会被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TerminateProcess，跟ExitProcess一样是可能造成内存泄露的。另外它是异步的，即只是通知要终止目标进程，返回后并不代表它已结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;三、作业&lt;/h2&gt;
&lt;p&gt;1.基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作业是进程的容器&lt;/strong&gt;，对一个或多个进程附加一定的限制，进行统一管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使作业只包含了一个进程也是有用的，因为这样能做一些普通不能进行的限制&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.主要的API:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CreateJobObject&lt;/td&gt;
&lt;td&gt;创建作业内核对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OpenJobObject&lt;/td&gt;
&lt;td&gt;根据Handle打开作业内核对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsProcessInJob&lt;/td&gt;
&lt;td&gt;验证某一个进程是否存在于作业中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SetInformationJobObject&lt;/td&gt;
&lt;td&gt;给作业加上各种限制&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QueryInformationJobObject&lt;/td&gt;
&lt;td&gt;查询作业对象的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AssignProcessToJobObject&lt;/td&gt;
&lt;td&gt;将进程放入作业&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TerminateJobObject&lt;/td&gt;
&lt;td&gt;终止作业内所有进程&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3.用于作业对象的基本用户界面限制的位标志&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标志&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_EXITWINDOWS&lt;/td&gt;
&lt;td&gt;用于防止进程通过ExitWindowsEx函数退出、关闭、重新引导或关闭系统电源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_READCLIPBOARD&lt;/td&gt;
&lt;td&gt;防止进程读取剪贴板的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_WRITECLIPBOARD&lt;/td&gt;
&lt;td&gt;防止进程删除剪贴板的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS&lt;/td&gt;
&lt;td&gt;防止进程通过SystemParametersInfor函数来改变系统参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_DISPLAYSETTINGS&lt;/td&gt;
&lt;td&gt;防止进程通过ChangeDisplaySettings函数来改变显示设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_GLOBALATOMS&lt;/td&gt;
&lt;td&gt;为作业赋予它自己的基本结构表，使作业中的进程只能访问该作业的表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_DESKTOP&lt;/td&gt;
&lt;td&gt;防止进程使用CreateDesktop或SwitchDesktop函数创建或转换桌面&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_HANDLES&lt;/td&gt;
&lt;td&gt;防止作业中的进程使用同一作业外部的进程创建的USER对象（如HWND）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_4"&gt;四、线程&lt;/h2&gt;
&lt;p&gt;1.基本概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程不执行代码的，&lt;strong&gt;是线程在进程地址空间内执行代码&lt;/strong&gt;，并对进程地址空间内的数据做操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个线程共享进程内的地址空间，包括进程的内核对象句柄表，因为句柄表的存在依赖于进程，而不是线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.线程的构成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关键：&lt;/p&gt;
&lt;p&gt;一个堆栈、
一些用于保护线程的寄存器、
一个指令寄存器（IP）、
堆栈指针寄存器（SP）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更详尽的构成&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（来自MSDN &lt;a href="http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;share&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;resources&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="n"&gt;addition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;maintains&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;handlers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;scheduling&lt;/span&gt; &lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;storage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;structures&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;save&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;scheduled&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;includes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;machine&lt;/span&gt; &lt;span class="n"&gt;registers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;environment&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Threads&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;their&lt;/span&gt; &lt;span class="n"&gt;own&lt;/span&gt; &lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;impersonating&lt;/span&gt; &lt;span class="n"&gt;clients&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.线程的启动&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化线程时会把 线程函数的入参(pvParam)、线程函数的指针(pfnStartAddrj) 压栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="" src="http://www.goorockey.com/uploads/2011/09/clip_image0011.png"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个线程还有一个指令寄存器（IP）和堆栈指针寄存器（SP）。IP初始指向BaseThreadStart函数，它包含在Kernel32.dll中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它主要是调用线程函数，并把函数返回值传给ExitThread：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;VOID&lt;/span&gt; &lt;span class="nf"&gt;BaseThreadStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PTHREAD_START_ROUTINE&lt;/span&gt; &lt;span class="n"&gt;pfnStartAddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kr"&gt;__try&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ExitThread&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;pfnStartAddr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;__except&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnhandledExceptionFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetExceptionInformation&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetExceptionCode&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//NOTE: We never get here. &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;之所以pfnStartAddr和pvParam压栈，就是因为线程开始运行时，CPU跳到IP指向BaseThreadStart，然后把pfnStartAddr和pvParam出栈，就把它们当做形参传给BaseThreadStart了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;五、其他&lt;/h2&gt;
&lt;p&gt;1.C/C++ Runtime Library的多线程版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在C/C++ Runtime Library中，有一些全局变量。它们有可能同时被多个线程访问，使它们的值无法确定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C/C++ Runtime Library为了适应多线程，出现多线程(MT)版本，改变一些全局变量和函数的特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要思路是为每个线程关联一个数据结构&lt;strong&gt;tiddata块&lt;/strong&gt;，里面都有各全局变量对于这个线程的副本。即每个线程访问的是属于自己的“全局变量”，有属于自己的独立环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而相关的函数对这些全局变量的操作也会改为对于&lt;strong&gt;tiddata块&lt;/strong&gt;对于值的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;_beginthreadex&lt;/span&gt;&lt;span class="err"&gt;就是在调用&lt;/span&gt;&lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="err"&gt;来创建线程的基础上，在线程初始化时创建线程关联的&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;tiddata&lt;/span&gt;&lt;span class="err"&gt;块&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="err"&gt;，并把这些全局变量拷贝到里面。所以&lt;/span&gt;&lt;span class="n"&gt;_beginthreadex&lt;/span&gt;&lt;span class="err"&gt;比&lt;/span&gt;&lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="err"&gt;要安全。&lt;/span&gt;
&lt;span class="n"&gt;_endthreadex&lt;/span&gt;&lt;span class="err"&gt;则是对应多做了清空关联数据结构的操作。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果在多线程版本的C/C++ Runtime Library中，用了CreateThread来创建线程，则线程初始化时不会有&lt;strong&gt;tiddata块&lt;/strong&gt;。而当函数要访问&lt;strong&gt;tiddata块&lt;/strong&gt;的时候，开始会访问失败，然后会自动生成一个，并把它与线程关联起来。但在一些情况下调用CreateThread就可能出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_beginthread比_beginthreadex、以及_endthread比_endthreadex的参数要少，少了对线程安全访问权的控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.伪句柄&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用GetCurrentThread和GetCurrentProcess得到句柄是自己句柄的引用，并不会使线程进程的使用计数加1，它们返回的句柄叫伪句柄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用CloseHandle关闭伪句柄时，会返回FALSE。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.纤程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UNIX服务器应用程序属于单线程程序（Windows定义），但其内部仿真了多线程工作。为了方便把UNIX服务器应用程序移植到Windows，就推出了纤程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConvertThreadToFiber 把线程转换为纤程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纤程不应该返回，返回会使线程和该线程所有的纤程都撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在单个线程里，每次只能运行一个纤程。可以用SwtichToFiber来切换纤程&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="windows"></category><category term="programming"></category></entry><entry><title>《Windows核心编程》读书笔记1--内核对象</title><link href="http://www.goorockey.com/blog/2011/09/02/windowshe-xin-bian-cheng-du-shu-bi-ji-1-nei-he-dui-xiang/" rel="alternate"></link><updated>2011-09-02T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2011-09-02:blog/2011/09/02/windowshe-xin-bian-cheng-du-shu-bi-ji-1-nei-he-dui-xiang/</id><summary type="html">
&lt;h2 id="_1"&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;1.内核对象有使用计数，当计数减为0时，内核对象被销毁。&lt;/p&gt;
&lt;p&gt;2.内核对象有安全描述符，控制该进程能做的操作。&lt;/p&gt;
&lt;p&gt;3.每个进程内有内核对象句柄表，记录使用中的内核对象。&lt;/p&gt;
&lt;h2 id="_2"&gt;二、内核对象&lt;/h2&gt;
&lt;p&gt;1.对内核对象的操作,只能通过调API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;应用程序无法在内存中找到表示内核对象的数据结构,也就无法直接修改其状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要对内核对象操作，只能先获得其句柄，然后调用window定义好的API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;2.内核对象的使用计数，记录在使用它的进程数&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内核对象是属于内核的，而不属于任何一个进程，包括创建它的哪个进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内核对象中有一个使用计数的数据，记录在使用它的进程数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有当使用计数为零时，该内核对象才会被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使创建它的进程终止了，该内核对象的使用计数不为零就不会被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3.内核对象的安全描述符，控制进程对其的使用权&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在创建内核对象的API中，都有一个“安全描述符”的参数，是用来控制对这个内核对象的使用权的
例如创建文件内存映射CreateFileMapping就有一个PSECURITY_ATTRIBUTES的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而在获取该内核对象的API OpenFileMapping中，会有一个表征获取该对象做什么操作的参数。
如果该用户允许对该内核对象做该操作，则成功返回该内核对象句柄，否则返回NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分辨一个对象是否为内核对象的标志是，创建该对象的API是否有“安全描述符”这个参数。
如创建GDI就没有该参数，所以GDI不是内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4.进程的内核对象句柄表，记录使用的内核对象&lt;/p&gt;
&lt;p&gt;内核对象句柄表结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;索引 (Handle)&lt;/th&gt;
&lt;th&gt;内核对象内存块的指针&lt;/th&gt;
&lt;th&gt;访问屏蔽（标志位的DWORD）&lt;/th&gt;
&lt;th&gt;继承标志（标志位的DWORD ）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每个进程内都有一个内核对象句柄表来记录它在使用的内核对象，表中包含该内核对象内存块的指针。
在内核对象的句柄就是该内核对象在此表中的索引值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建内核对象时，会在表中寻找空白项，并添加新项，并通过该内核对象指针对它的使用计数置1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用CloseHandle释放进程对该内核对象使用权时，就通过该指针对使用计数减1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;即使没有用CloseHandle，当进程终止时，会对句柄表中没有释放使用权的内核对象计数减1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5.进程间访问内核对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设置子进程继承父进程的内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建有名字的内核对象，并通过内核对象名字访问它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DuplicateHandle 复制内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6.当用Create*（如CreateMutex）创建有名字的内核对象&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;strong&gt;同名字&lt;/strong&gt;、&lt;strong&gt;同类&lt;/strong&gt;的内核对象已存在，则返回该内核对象的Handle；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;strong&gt;同名字&lt;/strong&gt;、&lt;strong&gt;不同类&lt;/strong&gt;的内核对象已存在，则创建失败，并返回NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果没有同名字的内核对象存在，则创建新内核对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary><category term="windows"></category><category term="programming"></category></entry><entry><title>VC中对WM_NOTIFY的处理</title><link href="http://www.goorockey.com/blog/2011/08/19/vczhong-dui-wm_notifyde-chu-li/" rel="alternate"></link><updated>2011-08-19T00:00:00+08:00</updated><author><name>goorockey</name></author><id>tag:www.goorockey.com,2011-08-19:blog/2011/08/19/vczhong-dui-wm_notifyde-chu-li/</id><summary type="html">
&lt;p&gt;1.Reflect&lt;/p&gt;
&lt;p&gt;对于WM_NOTIFY消息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子控件没有Reflect，则由父窗口处理。
只要子控件（即消息对应最直接的控件）有了ON_NOTIFY_REFLECT就会被子控件处理,不会被父窗口所处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Reflect的意思就是把消息反射给子控件处理。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;大概的就是这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子控件有ON_NOTIFY_REFLECT&lt;/th&gt;
&lt;th&gt;父窗口有ON_NOTIFY&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;WM_NOTIFY未被处理&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被父窗口处理&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被子控件处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被子控件处理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--more--&gt;
&lt;p&gt;2.EX&lt;/p&gt;
&lt;p&gt;ON_NOTIFY和ON_NOTIFY_EX 以及 ON_NOTIFY_REFLECT和ON_NOTIFY_REFLECT_EX&lt;/p&gt;
&lt;p&gt;区别是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EX版本的处理函数有BOOL型返回值，表示处理的消息是否继续消息传递
返回TRUE，表示不继续；
返回FALSE，表示继续，即其他控件可以对它做处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;则EX的意思就是把消息重新放到消息循环，继续遍历别的CmdTargetObject。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;大概是这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;子控件ON_NOTIFY_REFLECT_EX返回值&lt;/th&gt;
&lt;th&gt;父窗口有ON_NOTIFY&lt;/th&gt;
&lt;th&gt;效果&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被子控件处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被子控件处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;WM_NOTIFY只被子控件处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY被子控件和父窗口处理&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</summary><category term="windows"></category><category term="vc"></category></entry></feed>